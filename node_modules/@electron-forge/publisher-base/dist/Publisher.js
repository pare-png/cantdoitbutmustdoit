"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Publisher {
  constructor(config, providedPlatforms) {
    this.config = config;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "__isElectronForgePublisher", void 0);

    this.config = config;
    Object.defineProperty(this, '__isElectronForgePublisher', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    if (this.defaultPlatforms) return this.defaultPlatforms;
    return ['win32', 'linux', 'darwin', 'mas'];
  }
  /**
   * Publishers must implement this method to publish the artifacts returned from
   * make calls.  If any errors occur you must throw them, failing silently or simply
   * logging will not propagate issues up to forge.
   *
   * Please note for a given version publish will be called multiple times, once
   * for each set of "platform" and "arch".  This means if you are publishing
   * darwin and win32 artifacts to somewhere like GitHub on the first publish call
   * you will have to create the version on GitHub and the second call will just
   * be appending files to the existing version.
   */


  async publish(opts) {
    // eslint-disable-line @typescript-eslint/no-unused-vars
    throw new Error(`Publisher ${this.name} did not implement the publish method`);
  }

}

exports.default = Publisher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9QdWJsaXNoZXIudHMiXSwibmFtZXMiOlsiUHVibGlzaGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJwcm92aWRlZFBsYXRmb3JtcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwicGxhdGZvcm1zIiwiZGVmYXVsdFBsYXRmb3JtcyIsInB1Ymxpc2giLCJvcHRzIiwiRXJyb3IiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQXNCZSxNQUFlQSxTQUFmLENBQXVEO0FBT3BFQyxFQUFBQSxXQUFXLENBQVFDLE1BQVIsRUFBNkJDLGlCQUE3QixFQUFrRTtBQUFBLFNBQTFERCxNQUEwRCxHQUExREEsTUFBMEQ7QUFBQSxTQUFyQ0MsaUJBQXFDLEdBQXJDQSxpQkFBcUM7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQzNFLFNBQUtELE1BQUwsR0FBY0EsTUFBZDtBQUNBRSxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsNEJBQTVCLEVBQTBEO0FBQ3hEQyxNQUFBQSxLQUFLLEVBQUUsSUFEaUQ7QUFFeERDLE1BQUFBLFVBQVUsRUFBRSxLQUY0QztBQUd4REMsTUFBQUEsWUFBWSxFQUFFO0FBSDBDLEtBQTFEO0FBS0Q7O0FBRUQsTUFBSUMsU0FBSixHQUFnQjtBQUNkLFFBQUksS0FBS04saUJBQVQsRUFBNEIsT0FBTyxLQUFLQSxpQkFBWjtBQUM1QixRQUFJLEtBQUtPLGdCQUFULEVBQTJCLE9BQU8sS0FBS0EsZ0JBQVo7QUFDM0IsV0FBTyxDQUFDLE9BQUQsRUFBVSxPQUFWLEVBQW1CLFFBQW5CLEVBQTZCLEtBQTdCLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7O0FBV0EsUUFBTUMsT0FBTixDQUFjQyxJQUFkLEVBQXNDO0FBQUU7QUFDdEMsVUFBTSxJQUFJQyxLQUFKLENBQVcsYUFBWSxLQUFLQyxJQUFLLHVDQUFqQyxDQUFOO0FBQ0Q7O0FBbkNtRSIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7XG4gIEZvcmdlUGxhdGZvcm0sIEZvcmdlQ29uZmlnLCBGb3JnZU1ha2VSZXN1bHQsIElGb3JnZVB1Ymxpc2hlcixcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVibGlzaGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBkaXJlY3Rvcnkgb2YgdGhlIGFwcHMgc291cmNlIGNvZGVcbiAgICovXG4gIGRpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJlc3VsdHMgZnJvbSBydW5uaW5nIHRoZSBtYWtlIGNvbW1hbmRcbiAgICovXG4gIG1ha2VSZXN1bHRzOiBGb3JnZU1ha2VSZXN1bHRbXTtcbiAgLyoqXG4gICAqIFRoZSByYXcgZm9yZ2VDb25maWcgdGhpcyBhcHAgaXMgdXNpbmcuXG4gICAqXG4gICAqIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgdXNlIHRoaXNcbiAgICovXG4gIGZvcmdlQ29uZmlnOiBGb3JnZUNvbmZpZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUHVibGlzaGVyPEM+IGltcGxlbWVudHMgSUZvcmdlUHVibGlzaGVyIHtcbiAgcHVibGljIGFic3RyYWN0IG5hbWU6IHN0cmluZztcblxuICBwdWJsaWMgZGVmYXVsdFBsYXRmb3Jtcz86IEZvcmdlUGxhdGZvcm1bXTtcblxuICBfX2lzRWxlY3Ryb25Gb3JnZVB1Ymxpc2hlciE6IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGNvbmZpZzogQywgcHJvdGVjdGVkIHByb3ZpZGVkUGxhdGZvcm1zPzogRm9yZ2VQbGF0Zm9ybVtdKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2lzRWxlY3Ryb25Gb3JnZVB1Ymxpc2hlcicsIHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtcygpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlZFBsYXRmb3JtcykgcmV0dXJuIHRoaXMucHJvdmlkZWRQbGF0Zm9ybXM7XG4gICAgaWYgKHRoaXMuZGVmYXVsdFBsYXRmb3JtcykgcmV0dXJuIHRoaXMuZGVmYXVsdFBsYXRmb3JtcztcbiAgICByZXR1cm4gWyd3aW4zMicsICdsaW51eCcsICdkYXJ3aW4nLCAnbWFzJ10gYXMgRm9yZ2VQbGF0Zm9ybVtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcHVibGlzaCB0aGUgYXJ0aWZhY3RzIHJldHVybmVkIGZyb21cbiAgICogbWFrZSBjYWxscy4gIElmIGFueSBlcnJvcnMgb2NjdXIgeW91IG11c3QgdGhyb3cgdGhlbSwgZmFpbGluZyBzaWxlbnRseSBvciBzaW1wbHlcbiAgICogbG9nZ2luZyB3aWxsIG5vdCBwcm9wYWdhdGUgaXNzdWVzIHVwIHRvIGZvcmdlLlxuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSBmb3IgYSBnaXZlbiB2ZXJzaW9uIHB1Ymxpc2ggd2lsbCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIG9uY2VcbiAgICogZm9yIGVhY2ggc2V0IG9mIFwicGxhdGZvcm1cIiBhbmQgXCJhcmNoXCIuICBUaGlzIG1lYW5zIGlmIHlvdSBhcmUgcHVibGlzaGluZ1xuICAgKiBkYXJ3aW4gYW5kIHdpbjMyIGFydGlmYWN0cyB0byBzb21ld2hlcmUgbGlrZSBHaXRIdWIgb24gdGhlIGZpcnN0IHB1Ymxpc2ggY2FsbFxuICAgKiB5b3Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSB0aGUgdmVyc2lvbiBvbiBHaXRIdWIgYW5kIHRoZSBzZWNvbmQgY2FsbCB3aWxsIGp1c3RcbiAgICogYmUgYXBwZW5kaW5nIGZpbGVzIHRvIHRoZSBleGlzdGluZyB2ZXJzaW9uLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChvcHRzOiBQdWJsaXNoZXJPcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdGhyb3cgbmV3IEVycm9yKGBQdWJsaXNoZXIgJHt0aGlzLm5hbWV9IGRpZCBub3QgaW1wbGVtZW50IHRoZSBwdWJsaXNoIG1ldGhvZGApO1xuICB9XG59XG4iXX0=