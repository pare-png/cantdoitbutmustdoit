"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validPackageManagerVersion = validPackageManagerVersion;
exports.default = _default;

require("source-map-support/register");

var _child_process = require("child_process");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _core = require("@electron-forge/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:check-system');

async function checkGitExists() {
  return new Promise(resolve => {
    (0, _child_process.exec)('git --version', err => resolve(!err));
  });
}

async function checkNodeVersion() {
  return Promise.resolve(_semver.default.gt(process.versions.node, '6.0.0'));
}

const NPM_WHITELISTED_VERSIONS = {
  all: '^3.0.0 || ^4.0.0 || ~5.1.0 || ~5.2.0 || >= 5.4.2',
  darwin: '>= 5.4.0',
  linux: '>= 5.4.0'
};
const YARN_WHITELISTED_VERSIONS = {
  all: '0.23.3 || 0.24.6 || >= 1.0.0',
  darwin: '0.27.5',
  linux: '0.27.5'
};

function validPackageManagerVersion(packageManager, version, whitelistedVersions, ora) {
  try {
    return _semver.default.satisfies(version, whitelistedVersions);
  } catch (e) {
    ora.warn(`Could not check ${packageManager} version "${version}", assuming incompatible`);
    d(`Exception while checking version: ${e}`);
    return false;
  }
}

function warnIfPackageManagerIsntAKnownGoodVersion(packageManager, version, whitelistedVersions, ora) {
  const osVersions = whitelistedVersions[process.platform];
  const versions = osVersions ? `${whitelistedVersions.all} || ${osVersions}` : whitelistedVersions.all;
  const versionString = version.toString();

  if (!validPackageManagerVersion(packageManager, versionString, versions, ora)) {
    ora.warn(`You are using ${packageManager}, but not a known good version.
The known versions that work with Electron Forge are: ${versions}`);
  }
}

async function checkPackageManagerVersion(ora) {
  return _core.utils.yarnOrNpmSpawn(['--version']).then(version => {
    const versionString = version.toString();

    if (_core.utils.hasYarn()) {
      warnIfPackageManagerIsntAKnownGoodVersion('Yarn', versionString, YARN_WHITELISTED_VERSIONS, ora);
    } else {
      warnIfPackageManagerIsntAKnownGoodVersion('NPM', versionString, NPM_WHITELISTED_VERSIONS, ora);
    }

    return true;
  });
}
/**
 * Some people know their system is OK and don't appreciate the 800ms lag in
 * start up that these checks (in particular the package manager check) costs.
 *
 * Simply creating this flag file in your home directory will skip these checks
 * and shave ~800ms off your forge start time.
 *
 * This is specifically not documented or everyone would make it.
 */


const SKIP_SYSTEM_CHECK = _path.default.resolve(_os.default.homedir(), '.skip-forge-system-check');

async function _default(ora) {
  if (!(await _fsExtra.default.pathExists(SKIP_SYSTEM_CHECK))) {
    d('checking system, create ~/.skip-forge-system-check to stop doing this');
    return (await Promise.all([checkGitExists(), checkNodeVersion(), checkPackageManagerVersion(ora)])).every(check => check);
  }

  d('skipping system check');
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2NoZWNrLXN5c3RlbS50cyJdLCJuYW1lcyI6WyJkIiwiY2hlY2tHaXRFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsImNoZWNrTm9kZVZlcnNpb24iLCJzZW12ZXIiLCJndCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJhbGwiLCJkYXJ3aW4iLCJsaW51eCIsIllBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJ2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbiIsInBhY2thZ2VNYW5hZ2VyIiwidmVyc2lvbiIsIndoaXRlbGlzdGVkVmVyc2lvbnMiLCJvcmEiLCJzYXRpc2ZpZXMiLCJlIiwid2FybiIsIndhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uIiwib3NWZXJzaW9ucyIsInBsYXRmb3JtIiwidmVyc2lvblN0cmluZyIsInRvU3RyaW5nIiwiY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJmb3JnZVV0aWxzIiwieWFybk9yTnBtU3Bhd24iLCJ0aGVuIiwiaGFzWWFybiIsIlNLSVBfU1lTVEVNX0NIRUNLIiwicGF0aCIsIm9zIiwiaG9tZWRpciIsImZzIiwicGF0aEV4aXN0cyIsImV2ZXJ5IiwiY2hlY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUdBLE1BQU1BLENBQUMsR0FBRyxvQkFBTSw2QkFBTixDQUFWOztBQUVBLGVBQWVDLGNBQWYsR0FBZ0M7QUFDOUIsU0FBTyxJQUFJQyxPQUFKLENBQXNCQyxPQUFELElBQWE7QUFDdkMsNkJBQUssZUFBTCxFQUF1QkMsR0FBRCxJQUFTRCxPQUFPLENBQUMsQ0FBQ0MsR0FBRixDQUF0QztBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVELGVBQWVDLGdCQUFmLEdBQWtDO0FBQ2hDLFNBQU9ILE9BQU8sQ0FB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LENBSUlDLEtBQUQsSUFBV0EsS0FKZCxDQUFQO0FBS0Q7O0FBQ0R6QyxFQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRDtBQUNBLFNBQU8sSUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7IHV0aWxzIGFzIGZvcmdlVXRpbHMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5pbXBvcnQgeyBPcmFJbXBsIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6Y2hlY2stc3lzdGVtJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0RXhpc3RzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgKGVycikgPT4gcmVzb2x2ZSghZXJyKSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja05vZGVWZXJzaW9uKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbXZlci5ndChwcm9jZXNzLnZlcnNpb25zLm5vZGUsICc2LjAuMCcpKTtcbn1cblxuY29uc3QgTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TID0ge1xuICBhbGw6ICdeMy4wLjAgfHwgXjQuMC4wIHx8IH41LjEuMCB8fCB+NS4yLjAgfHwgPj0gNS40LjInLFxuICBkYXJ3aW46ICc+PSA1LjQuMCcsXG4gIGxpbnV4OiAnPj0gNS40LjAnLFxufTtcbmNvbnN0IFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMgPSB7XG4gIGFsbDogJzAuMjMuMyB8fCAwLjI0LjYgfHwgPj0gMS4wLjAnLFxuICBkYXJ3aW46ICcwLjI3LjUnLFxuICBsaW51eDogJzAuMjcuNScsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24oXG4gIHBhY2thZ2VNYW5hZ2VyOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgd2hpdGVsaXN0ZWRWZXJzaW9uczogc3RyaW5nLFxuICBvcmE6IE9yYUltcGwsXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2VtdmVyLnNhdGlzZmllcyh2ZXJzaW9uLCB3aGl0ZWxpc3RlZFZlcnNpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG9yYS53YXJuIShgQ291bGQgbm90IGNoZWNrICR7cGFja2FnZU1hbmFnZXJ9IHZlcnNpb24gXCIke3ZlcnNpb259XCIsIGFzc3VtaW5nIGluY29tcGF0aWJsZWApO1xuICAgIGQoYEV4Y2VwdGlvbiB3aGlsZSBjaGVja2luZyB2ZXJzaW9uOiAke2V9YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uKFxuICBwYWNrYWdlTWFuYWdlcjogc3RyaW5nLFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4gIHdoaXRlbGlzdGVkVmVyc2lvbnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIG9yYTogT3JhSW1wbCxcbikge1xuICBjb25zdCBvc1ZlcnNpb25zID0gd2hpdGVsaXN0ZWRWZXJzaW9uc1twcm9jZXNzLnBsYXRmb3JtXTtcbiAgY29uc3QgdmVyc2lvbnMgPSBvc1ZlcnNpb25zID8gYCR7d2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGx9IHx8ICR7b3NWZXJzaW9uc31gIDogd2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGw7XG4gIGNvbnN0IHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uLnRvU3RyaW5nKCk7XG4gIGlmICghdmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24ocGFja2FnZU1hbmFnZXIsIHZlcnNpb25TdHJpbmcsIHZlcnNpb25zLCBvcmEpKSB7XG4gICAgb3JhLndhcm4hKGBZb3UgYXJlIHVzaW5nICR7cGFja2FnZU1hbmFnZXJ9LCBidXQgbm90IGEga25vd24gZ29vZCB2ZXJzaW9uLlxuVGhlIGtub3duIHZlcnNpb25zIHRoYXQgd29yayB3aXRoIEVsZWN0cm9uIEZvcmdlIGFyZTogJHt2ZXJzaW9uc31gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja1BhY2thZ2VNYW5hZ2VyVmVyc2lvbihvcmE6IE9yYUltcGwpIHtcbiAgcmV0dXJuIGZvcmdlVXRpbHMueWFybk9yTnBtU3Bhd24oWyctLXZlcnNpb24nXSlcbiAgICAudGhlbigodmVyc2lvbikgPT4ge1xuICAgICAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgICAgIGlmIChmb3JnZVV0aWxzLmhhc1lhcm4oKSkge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignWWFybicsIHZlcnNpb25TdHJpbmcsIFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMsIG9yYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignTlBNJywgdmVyc2lvblN0cmluZywgTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TLCBvcmEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTb21lIHBlb3BsZSBrbm93IHRoZWlyIHN5c3RlbSBpcyBPSyBhbmQgZG9uJ3QgYXBwcmVjaWF0ZSB0aGUgODAwbXMgbGFnIGluXG4gKiBzdGFydCB1cCB0aGF0IHRoZXNlIGNoZWNrcyAoaW4gcGFydGljdWxhciB0aGUgcGFja2FnZSBtYW5hZ2VyIGNoZWNrKSBjb3N0cy5cbiAqXG4gKiBTaW1wbHkgY3JlYXRpbmcgdGhpcyBmbGFnIGZpbGUgaW4geW91ciBob21lIGRpcmVjdG9yeSB3aWxsIHNraXAgdGhlc2UgY2hlY2tzXG4gKiBhbmQgc2hhdmUgfjgwMG1zIG9mZiB5b3VyIGZvcmdlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyBzcGVjaWZpY2FsbHkgbm90IGRvY3VtZW50ZWQgb3IgZXZlcnlvbmUgd291bGQgbWFrZSBpdC5cbiAqL1xuY29uc3QgU0tJUF9TWVNURU1fQ0hFQ0sgPSBwYXRoLnJlc29sdmUob3MuaG9tZWRpcigpLCAnLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIChvcmE6IE9yYUltcGwpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKFNLSVBfU1lTVEVNX0NIRUNLKSkge1xuICAgIGQoJ2NoZWNraW5nIHN5c3RlbSwgY3JlYXRlIH4vLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrIHRvIHN0b3AgZG9pbmcgdGhpcycpO1xuICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgY2hlY2tHaXRFeGlzdHMoKSxcbiAgICAgIGNoZWNrTm9kZVZlcnNpb24oKSxcbiAgICAgIGNoZWNrUGFja2FnZU1hbmFnZXJWZXJzaW9uKG9yYSksXG4gICAgXSkpLmV2ZXJ5KChjaGVjaykgPT4gY2hlY2spO1xuICB9XG4gIGQoJ3NraXBwaW5nIHN5c3RlbSBjaGVjaycpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbiJdfQ==