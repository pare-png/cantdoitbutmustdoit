"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _which = _interopRequireDefault(require("which"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Maker {
  constructor(configFetcher = {}, providedPlatforms) {
    this.configFetcher = configFetcher;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "__isElectronForgeMaker", void 0);

    Object.defineProperty(this, '__isElectronForgeMaker', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    return this.defaultPlatforms;
  } // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
  //       v5 style functionality in the new API


  prepareConfig(targetArch) {
    if (typeof this.configFetcher === 'function') {
      this.config = this.configFetcher(targetArch);
    } else {
      this.config = this.configFetcher;
    }
  }
  /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */


  isSupportedOnCurrentPlatform() {
    if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
      throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
    }

    return true;
  }
  /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */


  async make(opts) {
    // eslint-disable-line max-len, @typescript-eslint/no-unused-vars
    if (this.make === Maker.prototype.make) {
      throw new Error(`Maker ${this.name} did not implement the make method`);
    }

    return [];
  }
  /**
   * Helpers
   */

  /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */


  async ensureDirectory(dir) {
    if (await _fsExtra.default.pathExists(dir)) {
      await _fsExtra.default.remove(dir);
    }

    return _fsExtra.default.mkdirs(dir);
  }
  /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */


  async ensureFile(file) {
    if (await _fsExtra.default.pathExists(file)) {
      await _fsExtra.default.remove(file);
    }

    await _fsExtra.default.mkdirs(_path.default.dirname(file));
  }
  /**
   * Checks if the specified binaries exist, which are required for the maker to be used.
   */


  externalBinariesExist(binaries) {
    return binaries.every(binary => _which.default.sync(binary, {
      nothrow: true
    }) !== null);
  }
  /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */


  isInstalled(module) {
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      require(module);

      return true;
    } catch (e) {
      // Package doesn't exist -- must not be installable on this platform
      return false;
    }
  }

}

exports.default = Maker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJuYW1lcyI6WyJNYWtlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiZXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwiYmluYXJpZXMiLCJldmVyeSIsImJpbmFyeSIsIndoaWNoIiwic3luYyIsIm5vdGhyb3ciLCJpc0luc3RhbGxlZCIsIm1vZHVsZSIsInJlcXVpcmUiLCJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7O0FBa0NlLE1BQWVBLEtBQWYsQ0FBK0M7QUFTNURDLEVBQUFBLFdBQVcsQ0FDREMsYUFBNkMsR0FBRyxFQUQvQyxFQUVDQyxpQkFGRCxFQUdUO0FBQUEsU0FGUUQsYUFFUixHQUZRQSxhQUVSO0FBQUEsU0FEVUMsaUJBQ1YsR0FEVUEsaUJBQ1Y7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQ0FDLElBQUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQixJQUF0QixFQUE0Qix3QkFBNUIsRUFBc0Q7QUFDcERDLE1BQUFBLEtBQUssRUFBRSxJQUQ2QztBQUVwREMsTUFBQUEsVUFBVSxFQUFFLEtBRndDO0FBR3BEQyxNQUFBQSxZQUFZLEVBQUU7QUFIc0MsS0FBdEQ7QUFLRDs7QUFFRCxNQUFJQyxTQUFKLEdBQWdCO0FBQ2QsUUFBSSxLQUFLTixpQkFBVCxFQUE0QixPQUFPLEtBQUtBLGlCQUFaO0FBQzVCLFdBQU8sS0FBS08sZ0JBQVo7QUFDRCxHQXZCMkQsQ0F5QjVEO0FBQ0E7OztBQUNBQyxFQUFBQSxhQUFhLENBQUNDLFVBQUQsRUFBd0I7QUFDbkMsUUFBSSxPQUFPLEtBQUtWLGFBQVosS0FBOEIsVUFBbEMsRUFBOEM7QUFDNUMsV0FBS1csTUFBTCxHQUFlLEtBQUtYLGFBQU4sQ0FBd0RVLFVBQXhELENBQWQ7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLQyxNQUFMLEdBQWMsS0FBS1gsYUFBbkI7QUFDRDtBQUNGO0FBRUQ7Ozs7Ozs7Ozs7O0FBU0FZLEVBQUFBLDRCQUE0QixHQUFZO0FBQ3RDLFFBQUksS0FBS0EsNEJBQUwsS0FBc0NkLEtBQUssQ0FBQ2UsU0FBTixDQUFnQkQsNEJBQTFELEVBQXdGO0FBQ3RGLFlBQU0sSUFBSUUsS0FBSixDQUFXLFNBQVEsS0FBS0MsSUFBSyw0REFBN0IsQ0FBTjtBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7OztBQUlBLFFBQU1DLElBQU4sQ0FBV0MsSUFBWCxFQUFrRDtBQUFFO0FBQ2xELFFBQUksS0FBS0QsSUFBTCxLQUFjbEIsS0FBSyxDQUFDZSxTQUFOLENBQWdCRyxJQUFsQyxFQUF3QztBQUN0QyxZQUFNLElBQUlGLEtBQUosQ0FBVyxTQUFRLEtBQUtDLElBQUssb0NBQTdCLENBQU47QUFDRDs7QUFDRCxXQUFPLEVBQVA7QUFDRDtBQUVEOzs7O0FBSUE7Ozs7Ozs7O0FBTUEsUUFBTUcsZUFBTixDQUFzQkMsR0FBdEIsRUFBa0Q7QUFDaEQsUUFBSSxNQUFNQyxpQkFBR0MsVUFBSCxDQUFjRixHQUFkLENBQVYsRUFBOEI7QUFDNUIsWUFBTUMsaUJBQUdFLE1BQUgsQ0FBVUgsR0FBVixDQUFOO0FBQ0Q7O0FBQ0QsV0FBT0MsaUJBQUdHLE1BQUgsQ0FBVUosR0FBVixDQUFQO0FBQ0Q7QUFFRDs7Ozs7OztBQUtBLFFBQU1LLFVBQU4sQ0FBaUJDLElBQWpCLEVBQThDO0FBQzVDLFFBQUksTUFBTUwsaUJBQUdDLFVBQUgsQ0FBY0ksSUFBZCxDQUFWLEVBQStCO0FBQzdCLFlBQU1MLGlCQUFHRSxNQUFILENBQVVHLElBQVYsQ0FBTjtBQUNEOztBQUNELFVBQU1MLGlCQUFHRyxNQUFILENBQVVHLGNBQUtDLE9BQUwsQ0FBYUYsSUFBYixDQUFWLENBQU47QUFDRDtBQUVEOzs7OztBQUdBRyxFQUFBQSxxQkFBcUIsQ0FBQ0MsUUFBRCxFQUE4QjtBQUNqRCxXQUFPQSxRQUFRLENBQUNDLEtBQVQsQ0FBZ0JDLE1BQUQsSUFBWUMsZUFBTUMsSUFBTixDQUFXRixNQUFYLEVBQW1CO0FBQUVHLE1BQUFBLE9BQU8sRUFBRTtBQUFYLEtBQW5CLE1BQTBDLElBQXJFLENBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJQUMsRUFBQUEsV0FBVyxDQUFDQyxNQUFELEVBQTBCO0FBQ25DLFFBQUk7QUFDRjtBQUNBQyxNQUFBQSxPQUFPLENBQUNELE1BQUQsQ0FBUDs7QUFDQSxhQUFPLElBQVA7QUFDRCxLQUpELENBSUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQS9HMkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBGb3JnZUFyY2gsIEZvcmdlQ29uZmlnLCBGb3JnZVBsYXRmb3JtLCBJRm9yZ2VNYWtlcixcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgd2hpY2ggZnJvbSAnd2hpY2gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIHBhY2thZ2VkIEVsZWN0cm9uIGFwcGxpY2F0aW9uXG4gICAqL1xuICBkaXI6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgeW91IHNob3VsZCBwdXQgYWxsIHlvdXIgYXJ0aWZhY3RzIGluIChwb3RlbnRpYWxseSBpbiBzdWIgZm9sZGVycylcbiAgICogTk9URTogdGhpcyBkaXJlY3RvcnkgaXMgbm90IGd1YXJ1bnRlZWQgdG8gYWxyZWFkeSBleGlzdFxuICAgKi9cbiAgbWFrZURpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJlc29sdmVkIGh1bWFuIGZyaWVuZGx5IG5hbWUgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIGFwcE5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgcGxhdGZvcm0geW91IHNob3VsZCBtYWtlIGZvclxuICAgKi9cbiAgdGFyZ2V0UGxhdGZvcm06IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IGFyY2hpdGVjdHVyZSB5b3Ugc2hvdWxkIG1ha2UgZm9yXG4gICAqL1xuICB0YXJnZXRBcmNoOiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBGdWxseSByZXNvbHZlZCBmb3JnZSBjb25maWd1cmF0aW9uLCB5b3Ugc2hvdWxkbid0IHJlYWxseSBuZWVkIHRoaXNcbiAgICovXG4gIGZvcmdlQ29uZmlnOiBGb3JnZUNvbmZpZztcbiAgLyoqXG4gICAqIFRoZSBhcHBsaWNhdGlvbnMgcGFja2FnZS5qc29uIGZpbGVcbiAgICovXG4gIHBhY2thZ2VKU09OOiBhbnk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIE1ha2VyPEM+IGltcGxlbWVudHMgSUZvcmdlTWFrZXIge1xuICBwdWJsaWMgY29uZmlnITogQztcblxuICBwdWJsaWMgYWJzdHJhY3QgbmFtZTogc3RyaW5nO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCBkZWZhdWx0UGxhdGZvcm1zOiBGb3JnZVBsYXRmb3JtW107XG5cbiAgX19pc0VsZWN0cm9uRm9yZ2VNYWtlciE6IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb25maWdGZXRjaGVyOiAoQyB8ICgoYXJjaDogRm9yZ2VBcmNoKSA9PiBDKSkgPSB7fSBhcyBDLFxuICAgIHByb3RlY3RlZCBwcm92aWRlZFBsYXRmb3Jtcz86IEZvcmdlUGxhdGZvcm1bXSxcbiAgKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyJywge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm1zKCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVkUGxhdGZvcm1zKSByZXR1cm4gdGhpcy5wcm92aWRlZFBsYXRmb3JtcztcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UGxhdGZvcm1zO1xuICB9XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMsIGl0IGlzIGFuIGV5ZS1zb3JlIGFuZCBpcyBhIG5hc3R5IGhhY2sgdG8gcHJvdmlkZSBmb3JnZVxuICAvLyAgICAgICB2NSBzdHlsZSBmdW5jdGlvbmFsaXR5IGluIHRoZSBuZXcgQVBJXG4gIHByZXBhcmVDb25maWcodGFyZ2V0QXJjaDogRm9yZ2VBcmNoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZ0ZldGNoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY29uZmlnID0gKHRoaXMuY29uZmlnRmV0Y2hlciBhcyBhbnkgYXMgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpKSh0YXJnZXRBcmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbmZpZ0ZldGNoZXIgYXMgQztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZXJzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFuZCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogdGhpcyBtYWtlciBjYW4gYmUgcnVuIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLiAgTm9ybWFsbHkgdGhpcyBpcyBqdXN0IGEgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgKiBjaGVjayBidXQgaXQgY2FuIGJlIGEgZGVlcGVyIGNoZWNrIGZvciBkZXBlbmRlbmNpZXMgbGlrZSBmYWtlLXJvb3Qgb3Igb3RoZXJcbiAgICogcmVxdWlyZWQgZXh0ZXJuYWwgYnVpbGQgdG9vbHMuXG4gICAqXG4gICAqIElmIHRoZSBpc3N1ZSBpcyBhIG1pc3NpbmcgZGVwZW5kZW5jeSB5b3Ugc2hvdWxkIGxvZyBvdXQgYSBIRUxQRlVMIGVycm9yIG1lc3NhZ2VcbiAgICogdGVsbGluZyB0aGUgZGV2ZWxvcGVyIGV4YWN0bHkgd2hhdCBpcyBtaXNzaW5nIGFuZCBpZiBwb3NzaWJsZSBob3cgdG8gZ2V0IGl0LlxuICAgKi9cbiAgaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtID09PSBNYWtlci5wcm90b3R5cGUuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWtlciAke3RoaXMubmFtZX0gZGlkIG5vdCBpbXBsZW1lbnQgdGhlIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0gbWV0aG9kYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIGFic29sdXRlIHBhdGhzXG4gICAqIHRvIHRoZSBhcnRpZmFjdHMgZ2VuZXJhdGVkIGJ5IHlvdXIgbWFrZXJcbiAgICovXG4gIGFzeW5jIG1ha2Uob3B0czogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGlmICh0aGlzLm1ha2UgPT09IE1ha2VyLnByb3RvdHlwZS5tYWtlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ha2VyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgbWFrZSBtZXRob2RgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGZvcmNlZCB0byBiZSBlbXB0eS5cbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzIGl0IGlzIGRlbGV0ZWQgYW5kIHJlY3JlYXRlZCwgdGhpc1xuICAgKiBpcyBhIGRlc3RydWN0aXZlIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRGlyZWN0b3J5KGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZGlyKSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGRpcik7XG4gICAgfVxuICAgIHJldHVybiBmcy5ta2RpcnMoZGlyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBwYXRoIHRvIHRoZSBmaWxlIGV4aXN0cyBhbmQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBpdCBpcyBkZWxldGVkIGFuZCB0aGUgcGF0aCBjcmVhdGVkXG4gICAqL1xuICBhc3luYyBlbnN1cmVGaWxlKGZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGUpKSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoZmlsZSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlycyhwYXRoLmRpcm5hbWUoZmlsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGJpbmFyaWVzIGV4aXN0LCB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIHRoZSBtYWtlciB0byBiZSB1c2VkLlxuICAgKi9cbiAgZXh0ZXJuYWxCaW5hcmllc0V4aXN0KGJpbmFyaWVzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBiaW5hcmllcy5ldmVyeSgoYmluYXJ5KSA9PiB3aGljaC5zeW5jKGJpbmFyeSwgeyBub3Rocm93OiB0cnVlIH0pICE9PSBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZHVsZSBpcyBpbnN0YWxsZWQsIHVzZWQgZm9yIHRlc3RpbmcgaWYgb3B0aW9uYWwgZGVwZW5kZW5jaWVzXG4gICAqIGFyZSBpbnN0YWxsZWQgb3Igbm90XG4gICAqL1xuICBpc0luc3RhbGxlZChtb2R1bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgIHJlcXVpcmUobW9kdWxlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFBhY2thZ2UgZG9lc24ndCBleGlzdCAtLSBtdXN0IG5vdCBiZSBpbnN0YWxsYWJsZSBvbiB0aGlzIHBsYXRmb3JtXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXX0=