"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmountImage = exports.mountImage = exports.getMountedImages = void 0;

require("source-map-support/register");

var _crossSpawnPromise = _interopRequireDefault(require("cross-spawn-promise"));

var _debug = _interopRequireDefault(require("debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:hdiutil');

const getMountedImages = async () => {
  const output = await (0, _crossSpawnPromise.default)('hdiutil', ['info']);
  const mounts = output.toString().split(/====\n/g);
  mounts.shift();
  const mountObjects = [];

  for (const mount of mounts) {
    try {
      const mountPath = /\/Volumes\/(.+)\n/g.exec(mount)[1];
      const imagePath = /image-path +: +(.+)\n/g.exec(mount)[1];
      mountObjects.push({
        mountPath,
        imagePath
      });
    } catch (err) {// Ignore
    }
  }

  d('identified active mounts', mountObjects);
  return mountObjects;
};

exports.getMountedImages = getMountedImages;

const mountImage = async filePath => {
  d('mounting image:', filePath);
  const output = await (0, _crossSpawnPromise.default)('hdiutil', ['attach', '-noautoopen', '-nobrowse', '-noverify', filePath]);
  const mountPath = /\/Volumes\/(.+)\n/g.exec(output.toString())[1];
  d('mounted at:', mountPath);
  return {
    mountPath,
    imagePath: filePath
  };
};

exports.mountImage = mountImage;

const unmountImage = async mount => {
  d('unmounting current mount:', mount);
  await (0, _crossSpawnPromise.default)('hdiutil', ['unmount', '-force', `/Volumes/${mount.mountPath}`]);
};

exports.unmountImage = unmountImage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2hkaXV0aWwudHMiXSwibmFtZXMiOlsiZCIsImdldE1vdW50ZWRJbWFnZXMiLCJvdXRwdXQiLCJtb3VudHMiLCJ0b1N0cmluZyIsInNwbGl0Iiwic2hpZnQiLCJtb3VudE9iamVjdHMiLCJtb3VudCIsIm1vdW50UGF0aCIsImV4ZWMiLCJpbWFnZVBhdGgiLCJwdXNoIiwiZXJyIiwibW91bnRJbWFnZSIsImZpbGVQYXRoIiwidW5tb3VudEltYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUVBLE1BQU1BLENBQUMsR0FBRyxvQkFBTSx3QkFBTixDQUFWOztBQU9PLE1BQU1DLGdCQUFnQixHQUFHLFlBQThCO0FBQzVELFFBQU1DLE1BQU0sR0FBRyxNQUFNLGdDQUFhLFNBQWIsRUFBd0IsQ0FBQyxNQUFELENBQXhCLENBQXJCO0FBQ0EsUUFBTUMsTUFBTSxHQUFHRCxNQUFNLENBQUNFLFFBQVAsR0FBa0JDLEtBQWxCLENBQXdCLFNBQXhCLENBQWY7QUFDQUYsRUFBQUEsTUFBTSxDQUFDRyxLQUFQO0FBRUEsUUFBTUMsWUFBWSxHQUFHLEVBQXJCOztBQUVBLE9BQUssTUFBTUMsS0FBWCxJQUFvQkwsTUFBcEIsRUFBNEI7QUFDMUIsUUFBSTtBQUNGLFlBQU1NLFNBQVMsR0FBRyxxQkFBcUJDLElBQXJCLENBQTBCRixLQUExQixFQUFrQyxDQUFsQyxDQUFsQjtBQUNBLFlBQU1HLFNBQVMsR0FBRyx5QkFBeUJELElBQXpCLENBQThCRixLQUE5QixFQUFzQyxDQUF0QyxDQUFsQjtBQUNBRCxNQUFBQSxZQUFZLENBQUNLLElBQWIsQ0FBa0I7QUFBRUgsUUFBQUEsU0FBRjtBQUFhRSxRQUFBQTtBQUFiLE9BQWxCO0FBQ0QsS0FKRCxDQUlFLE9BQU9FLEdBQVAsRUFBWSxDQUNaO0FBQ0Q7QUFDRjs7QUFFRGIsRUFBQUEsQ0FBQyxDQUFDLDBCQUFELEVBQTZCTyxZQUE3QixDQUFEO0FBQ0EsU0FBT0EsWUFBUDtBQUNELENBbkJNOzs7O0FBcUJBLE1BQU1PLFVBQVUsR0FBRyxNQUFPQyxRQUFQLElBQTRDO0FBQ3BFZixFQUFBQSxDQUFDLENBQUMsaUJBQUQsRUFBb0JlLFFBQXBCLENBQUQ7QUFDQSxRQUFNYixNQUFNLEdBQUcsTUFBTSxnQ0FBYSxTQUFiLEVBQXdCLENBQUMsUUFBRCxFQUFXLGFBQVgsRUFBMEIsV0FBMUIsRUFBdUMsV0FBdkMsRUFBb0RhLFFBQXBELENBQXhCLENBQXJCO0FBQ0EsUUFBTU4sU0FBUyxHQUFHLHFCQUFxQkMsSUFBckIsQ0FBMEJSLE1BQU0sQ0FBQ0UsUUFBUCxFQUExQixFQUE4QyxDQUE5QyxDQUFsQjtBQUNBSixFQUFBQSxDQUFDLENBQUMsYUFBRCxFQUFnQlMsU0FBaEIsQ0FBRDtBQUVBLFNBQU87QUFDTEEsSUFBQUEsU0FESztBQUVMRSxJQUFBQSxTQUFTLEVBQUVJO0FBRk4sR0FBUDtBQUlELENBVk07Ozs7QUFZQSxNQUFNQyxZQUFZLEdBQUcsTUFBT1IsS0FBUCxJQUF3QjtBQUNsRFIsRUFBQUEsQ0FBQyxDQUFDLDJCQUFELEVBQThCUSxLQUE5QixDQUFEO0FBQ0EsUUFBTSxnQ0FBYSxTQUFiLEVBQXdCLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBdUIsWUFBV0EsS0FBSyxDQUFDQyxTQUFVLEVBQWxELENBQXhCLENBQU47QUFDRCxDQUhNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNwYXduUHJvbWlzZSBmcm9tICdjcm9zcy1zcGF3bi1wcm9taXNlJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6aGRpdXRpbCcpO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1vdW50IHtcbiAgbW91bnRQYXRoOiBzdHJpbmc7XG4gIGltYWdlUGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0TW91bnRlZEltYWdlcyA9IGFzeW5jICgpOiBQcm9taXNlPE1vdW50W10+ID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgc3Bhd25Qcm9taXNlKCdoZGl1dGlsJywgWydpbmZvJ10pO1xuICBjb25zdCBtb3VudHMgPSBvdXRwdXQudG9TdHJpbmcoKS5zcGxpdCgvPT09PVxcbi9nKTtcbiAgbW91bnRzLnNoaWZ0KCk7XG5cbiAgY29uc3QgbW91bnRPYmplY3RzID0gW107XG5cbiAgZm9yIChjb25zdCBtb3VudCBvZiBtb3VudHMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW91bnRQYXRoID0gL1xcL1ZvbHVtZXNcXC8oLispXFxuL2cuZXhlYyhtb3VudCkhWzFdO1xuICAgICAgY29uc3QgaW1hZ2VQYXRoID0gL2ltYWdlLXBhdGggKzogKyguKylcXG4vZy5leGVjKG1vdW50KSFbMV07XG4gICAgICBtb3VudE9iamVjdHMucHVzaCh7IG1vdW50UGF0aCwgaW1hZ2VQYXRoIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWdub3JlXG4gICAgfVxuICB9XG5cbiAgZCgnaWRlbnRpZmllZCBhY3RpdmUgbW91bnRzJywgbW91bnRPYmplY3RzKTtcbiAgcmV0dXJuIG1vdW50T2JqZWN0cztcbn07XG5cbmV4cG9ydCBjb25zdCBtb3VudEltYWdlID0gYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPE1vdW50PiA9PiB7XG4gIGQoJ21vdW50aW5nIGltYWdlOicsIGZpbGVQYXRoKTtcbiAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgc3Bhd25Qcm9taXNlKCdoZGl1dGlsJywgWydhdHRhY2gnLCAnLW5vYXV0b29wZW4nLCAnLW5vYnJvd3NlJywgJy1ub3ZlcmlmeScsIGZpbGVQYXRoXSk7XG4gIGNvbnN0IG1vdW50UGF0aCA9IC9cXC9Wb2x1bWVzXFwvKC4rKVxcbi9nLmV4ZWMob3V0cHV0LnRvU3RyaW5nKCkpIVsxXTtcbiAgZCgnbW91bnRlZCBhdDonLCBtb3VudFBhdGgpO1xuXG4gIHJldHVybiB7XG4gICAgbW91bnRQYXRoLFxuICAgIGltYWdlUGF0aDogZmlsZVBhdGgsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdW5tb3VudEltYWdlID0gYXN5bmMgKG1vdW50OiBNb3VudCkgPT4ge1xuICBkKCd1bm1vdW50aW5nIGN1cnJlbnQgbW91bnQ6JywgbW91bnQpO1xuICBhd2FpdCBzcGF3blByb21pc2UoJ2hkaXV0aWwnLCBbJ3VubW91bnQnLCAnLWZvcmNlJywgYC9Wb2x1bWVzLyR7bW91bnQubW91bnRQYXRofWBdKTtcbn07XG4iXX0=