"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _readPackageJson = require("./read-package-json");

var _electronVersion = require("./electron-version");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:project-resolver'); // FIXME: If we want getElectronVersion to be overridable by plugins
//        and / or forge config then we need to be able to resolve
//        the dir without calling getElectronVersion

var _default = async dir => {
  let mDir = dir;
  let bestGuessDir = null;
  let lastError = null;
  let prevDir;

  while (prevDir !== mDir) {
    prevDir = mDir;

    const testPath = _path.default.resolve(mDir, 'package.json');

    d('searching for project in:', mDir);

    if (await _fsExtra.default.pathExists(testPath)) {
      const packageJSON = await (0, _readPackageJson.readRawPackageJson)(mDir); // TODO: Move this check to inside the forge config resolver and use
      //       mutatedPackageJson reader

      try {
        await (0, _electronVersion.getElectronVersion)(mDir, packageJSON);
      } catch (err) {
        lastError = err.message;
      }

      if (packageJSON.config && packageJSON.config.forge) {
        d('electron-forge compatible package.json found in', testPath);
        return mDir;
      }

      bestGuessDir = mDir;
    }

    mDir = _path.default.dirname(mDir);
  }

  if (bestGuessDir) {
    d('guessing on the best electron-forge package.json found in', bestGuessDir);
    return bestGuessDir;
  }

  if (lastError) {
    throw lastError;
  }

  return null;
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3Jlc29sdmUtZGlyLnRzIl0sIm5hbWVzIjpbImQiLCJkaXIiLCJtRGlyIiwiYmVzdEd1ZXNzRGlyIiwibGFzdEVycm9yIiwicHJldkRpciIsInRlc3RQYXRoIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJwYWNrYWdlSlNPTiIsImVyciIsIm1lc3NhZ2UiLCJjb25maWciLCJmb3JnZSIsImRpcm5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLGlDQUFOLENBQVYsQyxDQUVBO0FBQ0E7QUFDQTs7ZUFDZSxNQUFPQyxHQUFQLElBQXVCO0FBQ3BDLE1BQUlDLElBQUksR0FBR0QsR0FBWDtBQUNBLE1BQUlFLFlBQTJCLEdBQUcsSUFBbEM7QUFDQSxNQUFJQyxTQUF3QixHQUFHLElBQS9CO0FBRUEsTUFBSUMsT0FBSjs7QUFDQSxTQUFPQSxPQUFPLEtBQUtILElBQW5CLEVBQXlCO0FBQ3ZCRyxJQUFBQSxPQUFPLEdBQUdILElBQVY7O0FBQ0EsVUFBTUksUUFBUSxHQUFHQyxjQUFLQyxPQUFMLENBQWFOLElBQWIsRUFBbUIsY0FBbkIsQ0FBakI7O0FBQ0FGLElBQUFBLENBQUMsQ0FBQywyQkFBRCxFQUE4QkUsSUFBOUIsQ0FBRDs7QUFDQSxRQUFJLE1BQU1PLGlCQUFHQyxVQUFILENBQWNKLFFBQWQsQ0FBVixFQUFtQztBQUNqQyxZQUFNSyxXQUFXLEdBQUcsTUFBTSx5Q0FBbUJULElBQW5CLENBQTFCLENBRGlDLENBR2pDO0FBQ0E7O0FBQ0EsVUFBSTtBQUNGLGNBQU0seUNBQW1CQSxJQUFuQixFQUF5QlMsV0FBekIsQ0FBTjtBQUNELE9BRkQsQ0FFRSxPQUFPQyxHQUFQLEVBQVk7QUFDWlIsUUFBQUEsU0FBUyxHQUFHUSxHQUFHLENBQUNDLE9BQWhCO0FBQ0Q7O0FBRUQsVUFBSUYsV0FBVyxDQUFDRyxNQUFaLElBQXNCSCxXQUFXLENBQUNHLE1BQVosQ0FBbUJDLEtBQTdDLEVBQW9EO0FBQ2xEZixRQUFBQSxDQUFDLENBQUMsaURBQUQsRUFBb0RNLFFBQXBELENBQUQ7QUFDQSxlQUFPSixJQUFQO0FBQ0Q7O0FBRURDLE1BQUFBLFlBQVksR0FBR0QsSUFBZjtBQUNEOztBQUNEQSxJQUFBQSxJQUFJLEdBQUdLLGNBQUtTLE9BQUwsQ0FBYWQsSUFBYixDQUFQO0FBQ0Q7O0FBQ0QsTUFBSUMsWUFBSixFQUFrQjtBQUNoQkgsSUFBQUEsQ0FBQyxDQUFDLDJEQUFELEVBQThERyxZQUE5RCxDQUFEO0FBQ0EsV0FBT0EsWUFBUDtBQUNEOztBQUNELE1BQUlDLFNBQUosRUFBZTtBQUNiLFVBQU1BLFNBQU47QUFDRDs7QUFDRCxTQUFPLElBQVA7QUFDRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJlYWRSYXdQYWNrYWdlSnNvbiB9IGZyb20gJy4vcmVhZC1wYWNrYWdlLWpzb24nO1xuaW1wb3J0IHsgZ2V0RWxlY3Ryb25WZXJzaW9uIH0gZnJvbSAnLi9lbGVjdHJvbi12ZXJzaW9uJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpwcm9qZWN0LXJlc29sdmVyJyk7XG5cbi8vIEZJWE1FOiBJZiB3ZSB3YW50IGdldEVsZWN0cm9uVmVyc2lvbiB0byBiZSBvdmVycmlkYWJsZSBieSBwbHVnaW5zXG4vLyAgICAgICAgYW5kIC8gb3IgZm9yZ2UgY29uZmlnIHRoZW4gd2UgbmVlZCB0byBiZSBhYmxlIHRvIHJlc29sdmVcbi8vICAgICAgICB0aGUgZGlyIHdpdGhvdXQgY2FsbGluZyBnZXRFbGVjdHJvblZlcnNpb25cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChkaXI6IHN0cmluZykgPT4ge1xuICBsZXQgbURpciA9IGRpcjtcbiAgbGV0IGJlc3RHdWVzc0Rpcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGxldCBsYXN0RXJyb3I6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBwcmV2RGlyO1xuICB3aGlsZSAocHJldkRpciAhPT0gbURpcikge1xuICAgIHByZXZEaXIgPSBtRGlyO1xuICAgIGNvbnN0IHRlc3RQYXRoID0gcGF0aC5yZXNvbHZlKG1EaXIsICdwYWNrYWdlLmpzb24nKTtcbiAgICBkKCdzZWFyY2hpbmcgZm9yIHByb2plY3QgaW46JywgbURpcik7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHModGVzdFBhdGgpKSB7XG4gICAgICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRSYXdQYWNrYWdlSnNvbihtRGlyKTtcblxuICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGNoZWNrIHRvIGluc2lkZSB0aGUgZm9yZ2UgY29uZmlnIHJlc29sdmVyIGFuZCB1c2VcbiAgICAgIC8vICAgICAgIG11dGF0ZWRQYWNrYWdlSnNvbiByZWFkZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdldEVsZWN0cm9uVmVyc2lvbihtRGlyLCBwYWNrYWdlSlNPTik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrYWdlSlNPTi5jb25maWcgJiYgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgICAgIGQoJ2VsZWN0cm9uLWZvcmdlIGNvbXBhdGlibGUgcGFja2FnZS5qc29uIGZvdW5kIGluJywgdGVzdFBhdGgpO1xuICAgICAgICByZXR1cm4gbURpcjtcbiAgICAgIH1cblxuICAgICAgYmVzdEd1ZXNzRGlyID0gbURpcjtcbiAgICB9XG4gICAgbURpciA9IHBhdGguZGlybmFtZShtRGlyKTtcbiAgfVxuICBpZiAoYmVzdEd1ZXNzRGlyKSB7XG4gICAgZCgnZ3Vlc3Npbmcgb24gdGhlIGJlc3QgZWxlY3Ryb24tZm9yZ2UgcGFja2FnZS5qc29uIGZvdW5kIGluJywgYmVzdEd1ZXNzRGlyKTtcbiAgICByZXR1cm4gYmVzdEd1ZXNzRGlyO1xuICB9XG4gIGlmIChsYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBsYXN0RXJyb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuIl19