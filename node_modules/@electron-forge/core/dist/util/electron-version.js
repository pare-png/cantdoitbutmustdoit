"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElectronVersion = getElectronVersion;
exports.updateElectronDependency = updateElectronDependency;
exports.PackageNotFoundError = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _findUp = _interopRequireDefault(require("find-up"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _yarnOrNpm = _interopRequireWildcard(require("./yarn-or-npm"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:electron-version');
const electronPackageNames = ['electron-prebuilt-compile', 'electron-prebuilt', 'electron-nightly', 'electron'];

function findElectronDep(dep) {
  return electronPackageNames.includes(dep);
}

async function findAncestorNodeModulesPath(dir) {
  if ((0, _yarnOrNpm.hasYarn)()) {
    const yarnLockPath = await (0, _findUp.default)('yarn.lock', {
      cwd: dir,
      type: 'file'
    });

    if (yarnLockPath) {
      const nodeModulesPath = _path.default.join(_path.default.dirname(yarnLockPath), 'node_modules');

      if (await _fsExtra.default.pathExists(nodeModulesPath)) {
        return nodeModulesPath;
      }
    }
  }

  return Promise.resolve(undefined);
}

async function determineNodeModulesPath(dir) {
  const nodeModulesPath = _path.default.join(dir, 'node_modules');

  if (await _fsExtra.default.pathExists(nodeModulesPath)) {
    return nodeModulesPath;
  }

  return findAncestorNodeModulesPath(dir);
}

class PackageNotFoundError extends Error {
  constructor(packageName, dir) {
    super(`Cannot find the package "${packageName}". Perhaps you need to run "${(0, _yarnOrNpm.default)()} install" in "${dir}"?`);
  }

}

exports.PackageNotFoundError = PackageNotFoundError;

async function getElectronVersion(dir, packageJSON) {
  if (!packageJSON.devDependencies) {
    throw new Error('package.json for app does not have any devDependencies'.red);
  }

  const packageName = electronPackageNames.find(pkg => packageJSON.devDependencies[pkg]);

  if (packageName === undefined) {
    throw new Error('Could not find any Electron packages in devDependencies');
  }

  let version = packageJSON.devDependencies[packageName];

  if (!_semver.default.valid(version)) {
    // It's not an exact version, find it in the actual module
    const nodeModulesPath = await determineNodeModulesPath(dir);

    if (!nodeModulesPath) {
      throw new PackageNotFoundError(packageName, dir);
    }

    const electronPackageJSONPath = _path.default.join(nodeModulesPath, packageName, 'package.json');

    if (await _fsExtra.default.pathExists(electronPackageJSONPath)) {
      const electronPackageJSON = await _fsExtra.default.readJson(electronPackageJSONPath); // eslint-disable-next-line prefer-destructuring

      version = electronPackageJSON.version;
    } else {
      throw new PackageNotFoundError(packageName, dir);
    }
  }

  return version;
}

function updateElectronDependency(packageJSON, dev, exact) {
  const alteredDev = [].concat(dev);
  let alteredExact = [].concat(exact);

  if (Object.keys(packageJSON.devDependencies).find(findElectronDep)) {
    alteredExact = alteredExact.filter(dep => dep !== 'electron');
  } else {
    const electronKey = Object.keys(packageJSON.dependencies).find(findElectronDep);

    if (electronKey) {
      alteredExact = alteredExact.filter(dep => dep !== 'electron');
      d(`Moving ${electronKey} from dependencies to devDependencies`);
      alteredDev.push(`${electronKey}@${packageJSON.dependencies[electronKey]}`);
      delete packageJSON.dependencies[electronKey];
    }
  }

  return [alteredDev, alteredExact];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2VsZWN0cm9uLXZlcnNpb24udHMiXSwibmFtZXMiOlsiZCIsImVsZWN0cm9uUGFja2FnZU5hbWVzIiwiZmluZEVsZWN0cm9uRGVwIiwiZGVwIiwiaW5jbHVkZXMiLCJmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgiLCJkaXIiLCJ5YXJuTG9ja1BhdGgiLCJjd2QiLCJ0eXBlIiwibm9kZU1vZHVsZXNQYXRoIiwicGF0aCIsImpvaW4iLCJkaXJuYW1lIiwiZnMiLCJwYXRoRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1bmRlZmluZWQiLCJkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgiLCJQYWNrYWdlTm90Rm91bmRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJwYWNrYWdlTmFtZSIsImdldEVsZWN0cm9uVmVyc2lvbiIsInBhY2thZ2VKU09OIiwiZGV2RGVwZW5kZW5jaWVzIiwicmVkIiwiZmluZCIsInBrZyIsInZlcnNpb24iLCJzZW12ZXIiLCJ2YWxpZCIsImVsZWN0cm9uUGFja2FnZUpTT05QYXRoIiwiZWxlY3Ryb25QYWNrYWdlSlNPTiIsInJlYWRKc29uIiwidXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5IiwiZGV2IiwiZXhhY3QiLCJhbHRlcmVkRGV2IiwiY29uY2F0IiwiYWx0ZXJlZEV4YWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImVsZWN0cm9uS2V5IiwiZGVwZW5kZW5jaWVzIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLGlDQUFOLENBQVY7QUFFQSxNQUFNQyxvQkFBb0IsR0FBRyxDQUMzQiwyQkFEMkIsRUFFM0IsbUJBRjJCLEVBRzNCLGtCQUgyQixFQUkzQixVQUoyQixDQUE3Qjs7QUFPQSxTQUFTQyxlQUFULENBQXlCQyxHQUF6QixFQUErQztBQUM3QyxTQUFPRixvQkFBb0IsQ0FBQ0csUUFBckIsQ0FBOEJELEdBQTlCLENBQVA7QUFDRDs7QUFFRCxlQUFlRSwyQkFBZixDQUEyQ0MsR0FBM0MsRUFBcUY7QUFDbkYsTUFBSSx5QkFBSixFQUFlO0FBQ2IsVUFBTUMsWUFBWSxHQUFHLE1BQU0scUJBQU8sV0FBUCxFQUFvQjtBQUFFQyxNQUFBQSxHQUFHLEVBQUVGLEdBQVA7QUFBWUcsTUFBQUEsSUFBSSxFQUFFO0FBQWxCLEtBQXBCLENBQTNCOztBQUNBLFFBQUlGLFlBQUosRUFBa0I7QUFDaEIsWUFBTUcsZUFBZSxHQUFHQyxjQUFLQyxJQUFMLENBQVVELGNBQUtFLE9BQUwsQ0FBYU4sWUFBYixDQUFWLEVBQXNDLGNBQXRDLENBQXhCOztBQUNBLFVBQUksTUFBTU8saUJBQUdDLFVBQUgsQ0FBY0wsZUFBZCxDQUFWLEVBQTBDO0FBQ3hDLGVBQU9BLGVBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT00sT0FBTyxDQUFDQyxPQUFSLENBQWdCQyxTQUFoQixDQUFQO0FBQ0Q7O0FBRUQsZUFBZUMsd0JBQWYsQ0FBd0NiLEdBQXhDLEVBQWtGO0FBQ2hGLFFBQU1JLGVBQW1DLEdBQUdDLGNBQUtDLElBQUwsQ0FBVU4sR0FBVixFQUFlLGNBQWYsQ0FBNUM7O0FBQ0EsTUFBSSxNQUFNUSxpQkFBR0MsVUFBSCxDQUFjTCxlQUFkLENBQVYsRUFBMEM7QUFDeEMsV0FBT0EsZUFBUDtBQUNEOztBQUNELFNBQU9MLDJCQUEyQixDQUFDQyxHQUFELENBQWxDO0FBQ0Q7O0FBRU0sTUFBTWMsb0JBQU4sU0FBbUNDLEtBQW5DLENBQXlDO0FBQzlDQyxFQUFBQSxXQUFXLENBQUNDLFdBQUQsRUFBc0JqQixHQUF0QixFQUFtQztBQUM1QyxVQUFPLDRCQUEyQmlCLFdBQVksK0JBQThCLHlCQUFZLGlCQUFnQmpCLEdBQUksSUFBNUc7QUFDRDs7QUFINkM7Ozs7QUFNekMsZUFBZWtCLGtCQUFmLENBQWtDbEIsR0FBbEMsRUFBK0NtQixXQUEvQyxFQUFrRjtBQUN2RixNQUFJLENBQUNBLFdBQVcsQ0FBQ0MsZUFBakIsRUFBa0M7QUFDaEMsVUFBTSxJQUFJTCxLQUFKLENBQVUseURBQXlETSxHQUFuRSxDQUFOO0FBQ0Q7O0FBQ0QsUUFBTUosV0FBVyxHQUFHdEIsb0JBQW9CLENBQUMyQixJQUFyQixDQUEyQkMsR0FBRCxJQUFTSixXQUFXLENBQUNDLGVBQVosQ0FBNEJHLEdBQTVCLENBQW5DLENBQXBCOztBQUNBLE1BQUlOLFdBQVcsS0FBS0wsU0FBcEIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJRyxLQUFKLENBQVUseURBQVYsQ0FBTjtBQUNEOztBQUVELE1BQUlTLE9BQU8sR0FBR0wsV0FBVyxDQUFDQyxlQUFaLENBQTRCSCxXQUE1QixDQUFkOztBQUNBLE1BQUksQ0FBQ1EsZ0JBQU9DLEtBQVAsQ0FBYUYsT0FBYixDQUFMLEVBQTRCO0FBQUU7QUFDNUIsVUFBTXBCLGVBQWUsR0FBRyxNQUFNUyx3QkFBd0IsQ0FBQ2IsR0FBRCxDQUF0RDs7QUFDQSxRQUFJLENBQUNJLGVBQUwsRUFBc0I7QUFDcEIsWUFBTSxJQUFJVSxvQkFBSixDQUF5QkcsV0FBekIsRUFBc0NqQixHQUF0QyxDQUFOO0FBQ0Q7O0FBQ0QsVUFBTTJCLHVCQUF1QixHQUFHdEIsY0FBS0MsSUFBTCxDQUFVRixlQUFWLEVBQTJCYSxXQUEzQixFQUF3QyxjQUF4QyxDQUFoQzs7QUFDQSxRQUFJLE1BQU1ULGlCQUFHQyxVQUFILENBQWNrQix1QkFBZCxDQUFWLEVBQWtEO0FBQ2hELFlBQU1DLG1CQUFtQixHQUFHLE1BQU1wQixpQkFBR3FCLFFBQUgsQ0FBWUYsdUJBQVosQ0FBbEMsQ0FEZ0QsQ0FFaEQ7O0FBQ0FILE1BQUFBLE9BQU8sR0FBR0ksbUJBQW1CLENBQUNKLE9BQTlCO0FBQ0QsS0FKRCxNQUlPO0FBQ0wsWUFBTSxJQUFJVixvQkFBSixDQUF5QkcsV0FBekIsRUFBc0NqQixHQUF0QyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPd0IsT0FBUDtBQUNEOztBQUVNLFNBQVNNLHdCQUFULENBQ0xYLFdBREssRUFFTFksR0FGSyxFQUdMQyxLQUhLLEVBSWlCO0FBQ3RCLFFBQU1DLFVBQVUsR0FBSSxFQUFELENBQWlCQyxNQUFqQixDQUF3QkgsR0FBeEIsQ0FBbkI7QUFDQSxNQUFJSSxZQUFZLEdBQUksRUFBRCxDQUFpQkQsTUFBakIsQ0FBd0JGLEtBQXhCLENBQW5COztBQUNBLE1BQUlJLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbEIsV0FBVyxDQUFDQyxlQUF4QixFQUF5Q0UsSUFBekMsQ0FBOEMxQixlQUE5QyxDQUFKLEVBQW9FO0FBQ2xFdUMsSUFBQUEsWUFBWSxHQUFHQSxZQUFZLENBQUNHLE1BQWIsQ0FBcUJ6QyxHQUFELElBQVNBLEdBQUcsS0FBSyxVQUFyQyxDQUFmO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsVUFBTTBDLFdBQVcsR0FBR0gsTUFBTSxDQUFDQyxJQUFQLENBQVlsQixXQUFXLENBQUNxQixZQUF4QixFQUFzQ2xCLElBQXRDLENBQTJDMUIsZUFBM0MsQ0FBcEI7O0FBQ0EsUUFBSTJDLFdBQUosRUFBaUI7QUFDZkosTUFBQUEsWUFBWSxHQUFHQSxZQUFZLENBQUNHLE1BQWIsQ0FBcUJ6QyxHQUFELElBQVNBLEdBQUcsS0FBSyxVQUFyQyxDQUFmO0FBQ0FILE1BQUFBLENBQUMsQ0FBRSxVQUFTNkMsV0FBWSx1Q0FBdkIsQ0FBRDtBQUNBTixNQUFBQSxVQUFVLENBQUNRLElBQVgsQ0FBaUIsR0FBRUYsV0FBWSxJQUFHcEIsV0FBVyxDQUFDcUIsWUFBWixDQUF5QkQsV0FBekIsQ0FBc0MsRUFBeEU7QUFDQSxhQUFPcEIsV0FBVyxDQUFDcUIsWUFBWixDQUF5QkQsV0FBekIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxDQUFDTixVQUFELEVBQWFFLFlBQWIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmaW5kVXAgZnJvbSAnZmluZC11cCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeWFybk9yTnBtLCB7IGhhc1lhcm4gfSBmcm9tICcuL3lhcm4tb3ItbnBtJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTplbGVjdHJvbi12ZXJzaW9uJyk7XG5cbmNvbnN0IGVsZWN0cm9uUGFja2FnZU5hbWVzID0gW1xuICAnZWxlY3Ryb24tcHJlYnVpbHQtY29tcGlsZScsXG4gICdlbGVjdHJvbi1wcmVidWlsdCcsXG4gICdlbGVjdHJvbi1uaWdodGx5JyxcbiAgJ2VsZWN0cm9uJyxcbl07XG5cbmZ1bmN0aW9uIGZpbmRFbGVjdHJvbkRlcChkZXA6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gZWxlY3Ryb25QYWNrYWdlTmFtZXMuaW5jbHVkZXMoZGVwKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZEFuY2VzdG9yTm9kZU1vZHVsZXNQYXRoKGRpcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKGhhc1lhcm4oKSkge1xuICAgIGNvbnN0IHlhcm5Mb2NrUGF0aCA9IGF3YWl0IGZpbmRVcCgneWFybi5sb2NrJywgeyBjd2Q6IGRpciwgdHlwZTogJ2ZpbGUnIH0pO1xuICAgIGlmICh5YXJuTG9ja1BhdGgpIHtcbiAgICAgIGNvbnN0IG5vZGVNb2R1bGVzUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoeWFybkxvY2tQYXRoKSwgJ25vZGVfbW9kdWxlcycpO1xuICAgICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMobm9kZU1vZHVsZXNQYXRoKSkge1xuICAgICAgICByZXR1cm4gbm9kZU1vZHVsZXNQYXRoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGV0ZXJtaW5lTm9kZU1vZHVsZXNQYXRoKGRpcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBwYXRoLmpvaW4oZGlyLCAnbm9kZV9tb2R1bGVzJyk7XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKG5vZGVNb2R1bGVzUGF0aCkpIHtcbiAgICByZXR1cm4gbm9kZU1vZHVsZXNQYXRoO1xuICB9XG4gIHJldHVybiBmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgoZGlyKTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhY2thZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwYWNrYWdlTmFtZTogc3RyaW5nLCBkaXI6IHN0cmluZykge1xuICAgIHN1cGVyKGBDYW5ub3QgZmluZCB0aGUgcGFja2FnZSBcIiR7cGFja2FnZU5hbWV9XCIuIFBlcmhhcHMgeW91IG5lZWQgdG8gcnVuIFwiJHt5YXJuT3JOcG0oKX0gaW5zdGFsbFwiIGluIFwiJHtkaXJ9XCI/YCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVsZWN0cm9uVmVyc2lvbihkaXI6IHN0cmluZywgcGFja2FnZUpTT046IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmICghcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlLmpzb24gZm9yIGFwcCBkb2VzIG5vdCBoYXZlIGFueSBkZXZEZXBlbmRlbmNpZXMnLnJlZCk7XG4gIH1cbiAgY29uc3QgcGFja2FnZU5hbWUgPSBlbGVjdHJvblBhY2thZ2VOYW1lcy5maW5kKChwa2cpID0+IHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llc1twa2ddKTtcbiAgaWYgKHBhY2thZ2VOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSBFbGVjdHJvbiBwYWNrYWdlcyBpbiBkZXZEZXBlbmRlbmNpZXMnKTtcbiAgfVxuXG4gIGxldCB2ZXJzaW9uID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXTtcbiAgaWYgKCFzZW12ZXIudmFsaWQodmVyc2lvbikpIHsgLy8gSXQncyBub3QgYW4gZXhhY3QgdmVyc2lvbiwgZmluZCBpdCBpbiB0aGUgYWN0dWFsIG1vZHVsZVxuICAgIGNvbnN0IG5vZGVNb2R1bGVzUGF0aCA9IGF3YWl0IGRldGVybWluZU5vZGVNb2R1bGVzUGF0aChkaXIpO1xuICAgIGlmICghbm9kZU1vZHVsZXNQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFja2FnZU5vdEZvdW5kRXJyb3IocGFja2FnZU5hbWUsIGRpcik7XG4gICAgfVxuICAgIGNvbnN0IGVsZWN0cm9uUGFja2FnZUpTT05QYXRoID0gcGF0aC5qb2luKG5vZGVNb2R1bGVzUGF0aCwgcGFja2FnZU5hbWUsICdwYWNrYWdlLmpzb24nKTtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhlbGVjdHJvblBhY2thZ2VKU09OUGF0aCkpIHtcbiAgICAgIGNvbnN0IGVsZWN0cm9uUGFja2FnZUpTT04gPSBhd2FpdCBmcy5yZWFkSnNvbihlbGVjdHJvblBhY2thZ2VKU09OUGF0aCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHZlcnNpb24gPSBlbGVjdHJvblBhY2thZ2VKU09OLnZlcnNpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYWNrYWdlTm90Rm91bmRFcnJvcihwYWNrYWdlTmFtZSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUVsZWN0cm9uRGVwZW5kZW5jeShcbiAgcGFja2FnZUpTT046IGFueSxcbiAgZGV2OiBzdHJpbmdbXSxcbiAgZXhhY3Q6IHN0cmluZ1tdLFxuKTogW3N0cmluZ1tdLCBzdHJpbmdbXV0ge1xuICBjb25zdCBhbHRlcmVkRGV2ID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZGV2KTtcbiAgbGV0IGFsdGVyZWRFeGFjdCA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KGV4YWN0KTtcbiAgaWYgKE9iamVjdC5rZXlzKHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llcykuZmluZChmaW5kRWxlY3Ryb25EZXApKSB7XG4gICAgYWx0ZXJlZEV4YWN0ID0gYWx0ZXJlZEV4YWN0LmZpbHRlcigoZGVwKSA9PiBkZXAgIT09ICdlbGVjdHJvbicpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVsZWN0cm9uS2V5ID0gT2JqZWN0LmtleXMocGFja2FnZUpTT04uZGVwZW5kZW5jaWVzKS5maW5kKGZpbmRFbGVjdHJvbkRlcCk7XG4gICAgaWYgKGVsZWN0cm9uS2V5KSB7XG4gICAgICBhbHRlcmVkRXhhY3QgPSBhbHRlcmVkRXhhY3QuZmlsdGVyKChkZXApID0+IGRlcCAhPT0gJ2VsZWN0cm9uJyk7XG4gICAgICBkKGBNb3ZpbmcgJHtlbGVjdHJvbktleX0gZnJvbSBkZXBlbmRlbmNpZXMgdG8gZGV2RGVwZW5kZW5jaWVzYCk7XG4gICAgICBhbHRlcmVkRGV2LnB1c2goYCR7ZWxlY3Ryb25LZXl9QCR7cGFja2FnZUpTT04uZGVwZW5kZW5jaWVzW2VsZWN0cm9uS2V5XX1gKTtcbiAgICAgIGRlbGV0ZSBwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXNbZWxlY3Ryb25LZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbYWx0ZXJlZERldiwgYWx0ZXJlZEV4YWN0XTtcbn1cbiJdfQ==