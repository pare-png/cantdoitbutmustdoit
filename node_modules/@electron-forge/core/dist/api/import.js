"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _asyncOra = require("@electron-forge/async-ora");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _initGit = _interopRequireDefault(require("./init-scripts/init-git"));

var _initNpm = require("./init-scripts/init-npm");

var _electronVersion = require("../util/electron-version");

var _forgeConfig = require("../util/forge-config");

var _messages = require("../util/messages");

var _installDependencies = _interopRequireWildcard(require("../util/install-dependencies"));

var _readPackageJson = require("../util/read-package-json");

var _upgradeForgeConfig = _interopRequireWildcard(require("../util/upgrade-forge-config"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:import');

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  confirmImport,
  shouldContinueOnExisting,
  shouldRemoveDependency,
  shouldUpdateScript,
  outDir
}) => {
  const calculatedOutDir = outDir || 'out';
  _asyncOra.asyncOra.interactive = interactive;
  d(`Attempting to import project in: ${dir}`);

  if (!(await _fsExtra.default.pathExists(dir)) || !(await _fsExtra.default.pathExists(_path.default.resolve(dir, 'package.json')))) {
    throw new Error(`We couldn't find a project in: ${dir}`);
  } // eslint-disable-next-line max-len


  if (typeof confirmImport === 'function') {
    if (!(await confirmImport())) {
      process.exit(0);
    }
  }

  await (0, _initGit.default)(dir);
  const importDeps = [].concat(_initNpm.deps);
  let importDevDeps = [].concat(_initNpm.devDeps);
  let importExactDevDeps = [].concat(_initNpm.exactDevDeps);
  let packageJSON = await (0, _readPackageJson.readRawPackageJson)(dir);

  if (packageJSON.config && packageJSON.config.forge) {
    if (packageJSON.config.forge.makers) {
      (0, _messages.warn)(interactive, 'It looks like this project is already configured for Electron Forge'.green);

      if (typeof shouldContinueOnExisting === 'function') {
        if (!(await shouldContinueOnExisting())) {
          process.exit(0);
        }
      }
    } else if (typeof packageJSON.config.forge === 'string') {
      (0, _messages.warn)(interactive, "We can't tell if the Electron Forge config is compatible because it's in an external JavaScript file, not trying to convert it and continuing anyway".yellow);
    } else {
      d('Upgrading an Electron Forge < 6 project');
      packageJSON.config.forge = (0, _upgradeForgeConfig.default)(packageJSON.config.forge);
      importDevDeps = (0, _upgradeForgeConfig.updateUpgradedForgeDevDeps)(packageJSON, importDevDeps);
    }
  }

  packageJSON.dependencies = packageJSON.dependencies || {};
  packageJSON.devDependencies = packageJSON.devDependencies || {};
  [importDevDeps, importExactDevDeps] = (0, _electronVersion.updateElectronDependency)(packageJSON, importDevDeps, importExactDevDeps);
  const keys = Object.keys(packageJSON.dependencies).concat(Object.keys(packageJSON.devDependencies));
  const buildToolPackages = {
    '@electron/get': 'already uses this module as a transitive dependency',
    'electron-builder': 'provides mostly equivalent functionality',
    'electron-download': 'already uses this module as a transitive dependency',
    'electron-forge': 'replaced with @electron-forge/cli',
    'electron-installer-debian': 'already uses this module as a transitive dependency',
    'electron-installer-dmg': 'already uses this module as a transitive dependency',
    'electron-installer-flatpak': 'already uses this module as a transitive dependency',
    'electron-installer-redhat': 'already uses this module as a transitive dependency',
    'electron-osx-sign': 'already uses this module as a transitive dependency',
    'electron-packager': 'already uses this module as a transitive dependency',
    'electron-winstaller': 'already uses this module as a transitive dependency'
  };

  for (const key of keys) {
    if (buildToolPackages[key]) {
      const explanation = buildToolPackages[key]; // eslint-disable-next-line max-len

      let remove = true;

      if (typeof shouldRemoveDependency === 'function') {
        remove = await shouldRemoveDependency(key, explanation);
      }

      if (remove) {
        delete packageJSON.dependencies[key];
        delete packageJSON.devDependencies[key];
      }
    }
  }

  packageJSON.scripts = packageJSON.scripts || {};
  d('reading current scripts object:', packageJSON.scripts);

  const updatePackageScript = async (scriptName, newValue) => {
    if (packageJSON.scripts[scriptName] !== newValue) {
      // eslint-disable-next-line max-len
      let update = true;

      if (typeof shouldUpdateScript === 'function') {
        update = await shouldUpdateScript(scriptName, newValue);
      }

      if (update) {
        packageJSON.scripts[scriptName] = newValue;
      }
    }
  };

  await updatePackageScript('start', 'electron-forge start');
  await updatePackageScript('package', 'electron-forge package');
  await updatePackageScript('make', 'electron-forge make');
  d('forgified scripts object:', packageJSON.scripts);

  const writeChanges = async () => {
    await (0, _asyncOra.asyncOra)('Writing modified package.json file', async () => {
      await _fsExtra.default.writeJson(_path.default.resolve(dir, 'package.json'), packageJSON, {
        spaces: 2
      });
    });
  };

  await writeChanges();
  await (0, _asyncOra.asyncOra)('Installing dependencies', async () => {
    d('deleting old dependencies forcefully');
    await _fsExtra.default.remove(_path.default.resolve(dir, 'node_modules/.bin/electron'));
    await _fsExtra.default.remove(_path.default.resolve(dir, 'node_modules/.bin/electron.cmd'));
    d('installing dependencies');
    await (0, _installDependencies.default)(dir, importDeps);
    d('installing devDependencies');
    await (0, _installDependencies.default)(dir, importDevDeps, _installDependencies.DepType.DEV);
    d('installing exactDevDependencies');
    await (0, _installDependencies.default)(dir, importExactDevDeps, _installDependencies.DepType.DEV, _installDependencies.DepVersionRestriction.EXACT);
  });
  packageJSON = await (0, _readPackageJson.readRawPackageJson)(dir);

  if (!packageJSON.version) {
    (0, _messages.warn)(interactive, 'Please set the "version" in your application\'s package.json'.yellow);
  }

  packageJSON.config = packageJSON.config || {};
  const templatePackageJSON = await (0, _readPackageJson.readRawPackageJson)(_path.default.resolve(__dirname, '../../tmpl'));

  if (packageJSON.config.forge) {
    if (typeof packageJSON.config.forge !== 'string') {
      packageJSON.config.forge = (0, _lodash.default)(templatePackageJSON.config.forge, packageJSON.config.forge);
    }
  } else {
    packageJSON.config.forge = templatePackageJSON.config.forge;
  }

  if (typeof packageJSON.config.forge !== 'string') {
    (0, _forgeConfig.setInitialForgeConfig)(packageJSON);
  }

  await writeChanges();
  await (0, _asyncOra.asyncOra)('Fixing .gitignore', async () => {
    if (await _fsExtra.default.pathExists(_path.default.resolve(dir, '.gitignore'))) {
      const gitignore = await _fsExtra.default.readFile(_path.default.resolve(dir, '.gitignore'));

      if (!gitignore.includes(calculatedOutDir)) {
        await _fsExtra.default.writeFile(_path.default.resolve(dir, '.gitignore'), `${gitignore}\n${calculatedOutDir}/`);
      }
    }
  });
  (0, _messages.info)(interactive, `

We have ATTEMPTED to convert your app to be in a format that electron-forge understands.

Thanks for using ${'"electron-forge"'.green}!!!`);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW1wb3J0LnRzIl0sIm5hbWVzIjpbImQiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJjb25maXJtSW1wb3J0Iiwic2hvdWxkQ29udGludWVPbkV4aXN0aW5nIiwic2hvdWxkUmVtb3ZlRGVwZW5kZW5jeSIsInNob3VsZFVwZGF0ZVNjcmlwdCIsIm91dERpciIsImNhbGN1bGF0ZWRPdXREaXIiLCJhc3luY09yYSIsImZzIiwicGF0aEV4aXN0cyIsInBhdGgiLCJyZXNvbHZlIiwiRXJyb3IiLCJleGl0IiwiaW1wb3J0RGVwcyIsImNvbmNhdCIsImRlcHMiLCJpbXBvcnREZXZEZXBzIiwiZGV2RGVwcyIsImltcG9ydEV4YWN0RGV2RGVwcyIsImV4YWN0RGV2RGVwcyIsInBhY2thZ2VKU09OIiwiY29uZmlnIiwiZm9yZ2UiLCJtYWtlcnMiLCJncmVlbiIsInllbGxvdyIsImRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsImtleXMiLCJPYmplY3QiLCJidWlsZFRvb2xQYWNrYWdlcyIsImtleSIsImV4cGxhbmF0aW9uIiwicmVtb3ZlIiwic2NyaXB0cyIsInVwZGF0ZVBhY2thZ2VTY3JpcHQiLCJzY3JpcHROYW1lIiwibmV3VmFsdWUiLCJ1cGRhdGUiLCJ3cml0ZUNoYW5nZXMiLCJ3cml0ZUpzb24iLCJzcGFjZXMiLCJEZXBUeXBlIiwiREVWIiwiRGVwVmVyc2lvblJlc3RyaWN0aW9uIiwiRVhBQ1QiLCJ2ZXJzaW9uIiwidGVtcGxhdGVQYWNrYWdlSlNPTiIsIl9fZGlybmFtZSIsImdpdGlnbm9yZSIsInJlYWRGaWxlIiwiaW5jbHVkZXMiLCJ3cml0ZUZpbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0sdUJBQU4s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QUpELE1BSU87QUFDTEYsSUFBQUEsV0FBVyxDQUFDQyxNQUFaLENBQW1CQyxLQUFuQixHQUEyQnlCLG1CQUFtQixDQUFDMUIsTUFBcEIsQ0FBMkJDLEtBQXREO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPRixXQUFXLENBQUNDLE1BQVosQ0FBbUJDLEtBQTFCLEtBQW9DLFFBQXhDLEVBQWtEO0FBQ2hELDRDQUFzQkYsV0FBdEI7QUFDRDs7QUFFRCxRQUFNbUIsWUFBWSxFQUFsQjtBQUVBLFFBQU0sd0JBQVMsbUJBQVQsRUFBOEIsWUFBWTtBQUM5QyxRQUFJLE1BQU1oQyxpQkFBR0MsVUFBSCxDQUFjQyxjQUFLQyxPQUFMLENBQWFkLEdBQWIsRUFBa0IsWUFBbEIsQ0FBZCxDQUFWLEVBQTBEO0FBQ3hELFlBQU1xRCxTQUFTLEdBQUcsTUFBTTFDLGlCQUFHMkMsUUFBSCxDQUFZekMsY0FBS0MsT0FBTCxDQUFhZCxHQUFiLEVBQWtCLFlBQWxCLENBQVosQ0FBeEI7O0FBQ0EsVUFBSSxDQUFDcUQsU0FBUyxDQUFDRSxRQUFWLENBQW1COUMsZ0JBQW5CLENBQUwsRUFBMkM7QUFDekMsY0FBTUUsaUJBQUc2QyxTQUFILENBQWEzQyxjQUFLQyxPQUFMLENBQWFkLEdBQWIsRUFBa0IsWUFBbEIsQ0FBYixFQUErQyxHQUFFcUQsU0FBVSxLQUFJNUMsZ0JBQWlCLEdBQWhGLENBQU47QUFDRDtBQUNGO0FBQ0YsR0FQSyxDQUFOO0FBU0Esc0JBQUtOLFdBQUwsRUFBbUI7Ozs7bUJBSUYsbUJBQW1CeUIsS0FBTSxLQUoxQztBQUtELEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX21lcmdlIGZyb20gJ2xvZGFzaC5tZXJnZSc7XG5pbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IGluaXRHaXQgZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1naXQnO1xuaW1wb3J0IHsgZGVwcywgZGV2RGVwcywgZXhhY3REZXZEZXBzIH0gZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1ucG0nO1xuXG5pbXBvcnQgeyB1cGRhdGVFbGVjdHJvbkRlcGVuZGVuY3kgfSBmcm9tICcuLi91dGlsL2VsZWN0cm9uLXZlcnNpb24nO1xuaW1wb3J0IHsgc2V0SW5pdGlhbEZvcmdlQ29uZmlnIH0gZnJvbSAnLi4vdXRpbC9mb3JnZS1jb25maWcnO1xuaW1wb3J0IHsgaW5mbywgd2FybiB9IGZyb20gJy4uL3V0aWwvbWVzc2FnZXMnO1xuaW1wb3J0IGluc3RhbGxEZXBMaXN0LCB7IERlcFR5cGUsIERlcFZlcnNpb25SZXN0cmljdGlvbiB9IGZyb20gJy4uL3V0aWwvaW5zdGFsbC1kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgcmVhZFJhd1BhY2thZ2VKc29uIH0gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgdXBncmFkZUZvcmdlQ29uZmlnLCB7IHVwZGF0ZVVwZ3JhZGVkRm9yZ2VEZXZEZXBzIH0gZnJvbSAnLi4vdXRpbC91cGdyYWRlLWZvcmdlLWNvbmZpZyc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6aW1wb3J0Jyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgYXBwIHRvIGJlIGltcG9ydGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlIGluIG9yZGVyIHRvIGNvbmZpcm0gdGhlIHN0YXJ0XG4gICAqIG9mIGltcG9ydGluZ1xuICAgKi9cbiAgY29uZmlybUltcG9ydD86ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIC8qKlxuICAgKiBBbiBhc3luYyBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgaW1wb3J0IHNob3VsZCBjb250aW51ZSBpZiBpdFxuICAgKiBsb29rcyBsaWtlIGEgZm9yZ2UgcHJvamVjdCBhbHJlYWR5XG4gICAqL1xuICBzaG91bGRDb250aW51ZU9uRXhpc3Rpbmc/OiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAvKipcbiAgICogQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGRlcGVuZGVuY3kgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICovXG4gIHNob3VsZFJlbW92ZURlcGVuZGVuY3k/OiAoZGVwZW5kZW5jeTogc3RyaW5nLCBleHBsYW5hdGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAvKipcbiAgICogQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHNjcmlwdCBzaG91bGQgYmUgb3ZlcnJpZGRlbiB3aXRoIGEgZm9yZ2Ugb25lXG4gICAqL1xuICBzaG91bGRVcGRhdGVTY3JpcHQ/OiAoc2NyaXB0TmFtZTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIGdlbmVyYXRlZCBkaXN0cmlidXRhYmxlc1xuICAgKi9cbiAgb3V0RGlyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoe1xuICBkaXIgPSBwcm9jZXNzLmN3ZCgpLFxuICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICBjb25maXJtSW1wb3J0LFxuICBzaG91bGRDb250aW51ZU9uRXhpc3RpbmcsXG4gIHNob3VsZFJlbW92ZURlcGVuZGVuY3ksXG4gIHNob3VsZFVwZGF0ZVNjcmlwdCxcbiAgb3V0RGlyLFxufTogSW1wb3J0T3B0aW9ucykgPT4ge1xuICBjb25zdCBjYWxjdWxhdGVkT3V0RGlyID0gb3V0RGlyIHx8ICdvdXQnO1xuICBhc3luY09yYS5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXG4gIGQoYEF0dGVtcHRpbmcgdG8gaW1wb3J0IHByb2plY3QgaW46ICR7ZGlyfWApO1xuICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoZGlyKSB8fCAhYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLnJlc29sdmUoZGlyLCAncGFja2FnZS5qc29uJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZSBjb3VsZG4ndCBmaW5kIGEgcHJvamVjdCBpbjogJHtkaXJ9YCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBpZiAodHlwZW9mIGNvbmZpcm1JbXBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWF3YWl0IGNvbmZpcm1JbXBvcnQoKSkge1xuICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IGluaXRHaXQoZGlyKTtcblxuICBjb25zdCBpbXBvcnREZXBzID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZGVwcyk7XG4gIGxldCBpbXBvcnREZXZEZXBzID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZGV2RGVwcyk7XG4gIGxldCBpbXBvcnRFeGFjdERldkRlcHMgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdChleGFjdERldkRlcHMpO1xuXG4gIGxldCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRSYXdQYWNrYWdlSnNvbihkaXIpO1xuICBpZiAocGFja2FnZUpTT04uY29uZmlnICYmIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSkge1xuICAgIGlmIChwYWNrYWdlSlNPTi5jb25maWcuZm9yZ2UubWFrZXJzKSB7XG4gICAgICB3YXJuKGludGVyYWN0aXZlLCAnSXQgbG9va3MgbGlrZSB0aGlzIHByb2plY3QgaXMgYWxyZWFkeSBjb25maWd1cmVkIGZvciBFbGVjdHJvbiBGb3JnZScuZ3JlZW4pO1xuICAgICAgaWYgKHR5cGVvZiBzaG91bGRDb250aW51ZU9uRXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFhd2FpdCBzaG91bGRDb250aW51ZU9uRXhpc3RpbmcoKSkge1xuICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm4oaW50ZXJhY3RpdmUsIFwiV2UgY2FuJ3QgdGVsbCBpZiB0aGUgRWxlY3Ryb24gRm9yZ2UgY29uZmlnIGlzIGNvbXBhdGlibGUgYmVjYXVzZSBpdCdzIGluIGFuIGV4dGVybmFsIEphdmFTY3JpcHQgZmlsZSwgbm90IHRyeWluZyB0byBjb252ZXJ0IGl0IGFuZCBjb250aW51aW5nIGFueXdheVwiLnllbGxvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQoJ1VwZ3JhZGluZyBhbiBFbGVjdHJvbiBGb3JnZSA8IDYgcHJvamVjdCcpO1xuICAgICAgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlID0gdXBncmFkZUZvcmdlQ29uZmlnKHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSk7XG4gICAgICBpbXBvcnREZXZEZXBzID0gdXBkYXRlVXBncmFkZWRGb3JnZURldkRlcHMocGFja2FnZUpTT04sIGltcG9ydERldkRlcHMpO1xuICAgIH1cbiAgfVxuXG4gIHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcyA9IHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcyB8fCB7fTtcbiAgcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzIHx8IHt9O1xuXG4gIFtpbXBvcnREZXZEZXBzLCBpbXBvcnRFeGFjdERldkRlcHNdID0gdXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5KFxuICAgIHBhY2thZ2VKU09OLFxuICAgIGltcG9ydERldkRlcHMsXG4gICAgaW1wb3J0RXhhY3REZXZEZXBzLFxuICApO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXMpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXMpKTtcbiAgY29uc3QgYnVpbGRUb29sUGFja2FnZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0gPSB7XG4gICAgJ0BlbGVjdHJvbi9nZXQnOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24tYnVpbGRlcic6ICdwcm92aWRlcyBtb3N0bHkgZXF1aXZhbGVudCBmdW5jdGlvbmFsaXR5JyxcbiAgICAnZWxlY3Ryb24tZG93bmxvYWQnOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24tZm9yZ2UnOiAncmVwbGFjZWQgd2l0aCBAZWxlY3Ryb24tZm9yZ2UvY2xpJyxcbiAgICAnZWxlY3Ryb24taW5zdGFsbGVyLWRlYmlhbic6ICdhbHJlYWR5IHVzZXMgdGhpcyBtb2R1bGUgYXMgYSB0cmFuc2l0aXZlIGRlcGVuZGVuY3knLFxuICAgICdlbGVjdHJvbi1pbnN0YWxsZXItZG1nJzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLWluc3RhbGxlci1mbGF0cGFrJzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLWluc3RhbGxlci1yZWRoYXQnOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24tb3N4LXNpZ24nOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24tcGFja2FnZXInOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24td2luc3RhbGxlcic6ICdhbHJlYWR5IHVzZXMgdGhpcyBtb2R1bGUgYXMgYSB0cmFuc2l0aXZlIGRlcGVuZGVuY3knLFxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoYnVpbGRUb29sUGFja2FnZXNba2V5XSkge1xuICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBidWlsZFRvb2xQYWNrYWdlc1trZXldITtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBsZXQgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygc2hvdWxkUmVtb3ZlRGVwZW5kZW5jeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZW1vdmUgPSBhd2FpdCBzaG91bGRSZW1vdmVEZXBlbmRlbmN5KGtleSwgZXhwbGFuYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGRlbGV0ZSBwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgICAgZGVsZXRlIHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhY2thZ2VKU09OLnNjcmlwdHMgPSBwYWNrYWdlSlNPTi5zY3JpcHRzIHx8IHt9O1xuICBkKCdyZWFkaW5nIGN1cnJlbnQgc2NyaXB0cyBvYmplY3Q6JywgcGFja2FnZUpTT04uc2NyaXB0cyk7XG5cbiAgY29uc3QgdXBkYXRlUGFja2FnZVNjcmlwdCA9IGFzeW5jIChzY3JpcHROYW1lOiBzdHJpbmcsIG5ld1ZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocGFja2FnZUpTT04uc2NyaXB0c1tzY3JpcHROYW1lXSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBsZXQgdXBkYXRlID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygc2hvdWxkVXBkYXRlU2NyaXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHVwZGF0ZSA9IGF3YWl0IHNob3VsZFVwZGF0ZVNjcmlwdChzY3JpcHROYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHBhY2thZ2VKU09OLnNjcmlwdHNbc2NyaXB0TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgdXBkYXRlUGFja2FnZVNjcmlwdCgnc3RhcnQnLCAnZWxlY3Ryb24tZm9yZ2Ugc3RhcnQnKTtcbiAgYXdhaXQgdXBkYXRlUGFja2FnZVNjcmlwdCgncGFja2FnZScsICdlbGVjdHJvbi1mb3JnZSBwYWNrYWdlJyk7XG4gIGF3YWl0IHVwZGF0ZVBhY2thZ2VTY3JpcHQoJ21ha2UnLCAnZWxlY3Ryb24tZm9yZ2UgbWFrZScpO1xuXG4gIGQoJ2ZvcmdpZmllZCBzY3JpcHRzIG9iamVjdDonLCBwYWNrYWdlSlNPTi5zY3JpcHRzKTtcblxuICBjb25zdCB3cml0ZUNoYW5nZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYXN5bmNPcmEoJ1dyaXRpbmcgbW9kaWZpZWQgcGFja2FnZS5qc29uIGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5yZXNvbHZlKGRpciwgJ3BhY2thZ2UuanNvbicpLCBwYWNrYWdlSlNPTiwgeyBzcGFjZXM6IDIgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXdhaXQgd3JpdGVDaGFuZ2VzKCk7XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ0luc3RhbGxpbmcgZGVwZW5kZW5jaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGQoJ2RlbGV0aW5nIG9sZCBkZXBlbmRlbmNpZXMgZm9yY2VmdWxseScpO1xuICAgIGF3YWl0IGZzLnJlbW92ZShwYXRoLnJlc29sdmUoZGlyLCAnbm9kZV9tb2R1bGVzLy5iaW4vZWxlY3Ryb24nKSk7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHBhdGgucmVzb2x2ZShkaXIsICdub2RlX21vZHVsZXMvLmJpbi9lbGVjdHJvbi5jbWQnKSk7XG5cbiAgICBkKCdpbnN0YWxsaW5nIGRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RGVwcyk7XG5cbiAgICBkKCdpbnN0YWxsaW5nIGRldkRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RGV2RGVwcywgRGVwVHlwZS5ERVYpO1xuXG4gICAgZCgnaW5zdGFsbGluZyBleGFjdERldkRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RXhhY3REZXZEZXBzLCBEZXBUeXBlLkRFViwgRGVwVmVyc2lvblJlc3RyaWN0aW9uLkVYQUNUKTtcbiAgfSk7XG5cbiAgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkUmF3UGFja2FnZUpzb24oZGlyKTtcblxuICBpZiAoIXBhY2thZ2VKU09OLnZlcnNpb24pIHtcbiAgICB3YXJuKGludGVyYWN0aXZlLCAnUGxlYXNlIHNldCB0aGUgXCJ2ZXJzaW9uXCIgaW4geW91ciBhcHBsaWNhdGlvblxcJ3MgcGFja2FnZS5qc29uJy55ZWxsb3cpO1xuICB9XG5cbiAgcGFja2FnZUpTT04uY29uZmlnID0gcGFja2FnZUpTT04uY29uZmlnIHx8IHt9O1xuICBjb25zdCB0ZW1wbGF0ZVBhY2thZ2VKU09OID0gYXdhaXQgcmVhZFJhd1BhY2thZ2VKc29uKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi90bXBsJykpO1xuICBpZiAocGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgaWYgKHR5cGVvZiBwYWNrYWdlSlNPTi5jb25maWcuZm9yZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICBwYWNrYWdlSlNPTi5jb25maWcuZm9yZ2UgPSBfbWVyZ2UodGVtcGxhdGVQYWNrYWdlSlNPTi5jb25maWcuZm9yZ2UsIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSA9IHRlbXBsYXRlUGFja2FnZUpTT04uY29uZmlnLmZvcmdlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYWNrYWdlSlNPTi5jb25maWcuZm9yZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgc2V0SW5pdGlhbEZvcmdlQ29uZmlnKHBhY2thZ2VKU09OKTtcbiAgfVxuXG4gIGF3YWl0IHdyaXRlQ2hhbmdlcygpO1xuXG4gIGF3YWl0IGFzeW5jT3JhKCdGaXhpbmcgLmdpdGlnbm9yZScsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLnJlc29sdmUoZGlyLCAnLmdpdGlnbm9yZScpKSkge1xuICAgICAgY29uc3QgZ2l0aWdub3JlID0gYXdhaXQgZnMucmVhZEZpbGUocGF0aC5yZXNvbHZlKGRpciwgJy5naXRpZ25vcmUnKSk7XG4gICAgICBpZiAoIWdpdGlnbm9yZS5pbmNsdWRlcyhjYWxjdWxhdGVkT3V0RGlyKSkge1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUocGF0aC5yZXNvbHZlKGRpciwgJy5naXRpZ25vcmUnKSwgYCR7Z2l0aWdub3JlfVxcbiR7Y2FsY3VsYXRlZE91dERpcn0vYCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpbmZvKGludGVyYWN0aXZlLCBgXG5cbldlIGhhdmUgQVRURU1QVEVEIHRvIGNvbnZlcnQgeW91ciBhcHAgdG8gYmUgaW4gYSBmb3JtYXQgdGhhdCBlbGVjdHJvbi1mb3JnZSB1bmRlcnN0YW5kcy5cblxuVGhhbmtzIGZvciB1c2luZyAkeydcImVsZWN0cm9uLWZvcmdlXCInLmdyZWVufSEhIWApO1xufTtcbiJdfQ==