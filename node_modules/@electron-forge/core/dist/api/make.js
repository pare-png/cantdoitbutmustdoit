"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _get = require("@electron/get");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  skipPackage = false,
  arch = (0, _get.getHostArch)(),
  platform = process.platform,
  overrideTargets,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  let forgeConfig;
  await (0, _asyncOra.asyncOra)('Resolving Forge Config', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate makeable Electron application');
    }

    dir = resolvedDir;
    forgeConfig = await (0, _forgeConfig.default)(dir);
  });
  const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
  const actualTargetPlatform = platform;
  platform = platform === 'mas' ? 'darwin' : platform;

  if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
    throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
  }

  const makers = {};
  let targets = (overrideTargets || forgeConfig.makers).map(target => {
    if (typeof target === 'string') {
      return {
        name: target
      };
    }

    return target;
  });
  let targetId = 0;

  for (const target of targets) {
    let maker; // eslint-disable-next-line no-underscore-dangle

    if (target.__isElectronForgeMaker) {
      maker = target; // eslint-disable-next-line no-continue

      if (maker.platforms.indexOf(actualTargetPlatform) === -1) continue;
    } else {
      const resolvableTarget = target;
      const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

      if (!MakerClass) {
        throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
      }

      maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined); // eslint-disable-next-line no-continue

      if (maker.platforms.indexOf(actualTargetPlatform) === -1) continue;
    }

    if (!maker.isSupportedOnCurrentPlatform) {
      throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
    }

    if (!(await maker.isSupportedOnCurrentPlatform())) {
      throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
    }

    makers[targetId] = maker;
    targetId += 1;
  }

  if (!skipPackage) {
    (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
    await (0, _package.default)({
      dir,
      interactive,
      arch,
      outDir: actualOutDir,
      platform: actualTargetPlatform
    });
  } else {
    (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
  }

  targets = targets.filter((_, i) => makers[i]);
  (0, _messages.info)(interactive, `Making for the following targets: ${`${targets.map((t, i) => makers[i].name).join(', ')}`.cyan}`);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
  const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
  const outputs = [];
  await (0, _hook.runHook)(forgeConfig, 'preMake');

  for (const targetArch of (0, _parseArchs.default)(platform, arch, (await (0, _electronVersion.getElectronVersion)(dir, packageJSON)))) {
    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

    if (!(await _fsExtra.default.pathExists(packageDir))) {
      throw new Error(`Couldn't find packaged app at: ${packageDir}`);
    }

    targetId = 0; // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars

    for (const _target of targets) {
      const maker = makers[targetId];
      targetId += 1; // eslint-disable-next-line no-loop-func

      await (0, _asyncOra.asyncOra)(`Making for target: ${maker.name.green} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`, async () => {
        try {
          /**
           * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
           *
           * Currently it is assumed we have 1 maker per make call but that is
           * not enforced.  It is technically possible to have 1 maker be called
           * multiple times.  The "prepareConfig" method however implicitly
           * requires a lock that is not enforced.  There are two options:
           *
           *   * Provide makers a getConfig() method
           *   * Remove support for config being provided as a method
           *   * Change the entire API of maker from a single constructor to
           *     providing a MakerFactory
           */
          maker.prepareConfig(targetArch);
          const artifacts = await maker.make({
            appName,
            forgeConfig,
            packageJSON,
            targetArch,
            dir: packageDir,
            makeDir: _path.default.resolve(actualOutDir, 'make'),
            targetPlatform: actualTargetPlatform
          });
          outputs.push({
            artifacts,
            packageJSON,
            platform: actualTargetPlatform,
            arch: targetArch
          });
        } catch (err) {
          if (err) {
            // eslint-disable-next-line no-throw-literal
            throw {
              message: `An error occured while making for target: ${maker.name}`,
              stack: `${err.message}\n${err.stack}`
            };
          } else {
            throw new Error(`An unknown error occured while making for target: ${maker.name}`);
          }
        }
      });
    }
  } // If the postMake hooks modifies the locations / names of the outputs it must return
  // the new locations so that the publish step knows where to look


  return (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJNYWtlckltcGwiLCJNYWtlckJhc2UiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJwbGF0Zm9ybSIsIm92ZXJyaWRlVGFyZ2V0cyIsIm91dERpciIsImFzeW5jT3JhIiwiZm9yZ2VDb25maWciLCJyZXNvbHZlZERpciIsIkVycm9yIiwiYWN0dWFsT3V0RGlyIiwiYWN0dWFsVGFyZ2V0UGxhdGZvcm0iLCJpbmNsdWRlcyIsIm1ha2VycyIsInRhcmdldHMiLCJtYXAiLCJ0YXJnZXQiLCJuYW1lIiwidGFyZ2V0SWQiLCJtYWtlciIsIl9faXNFbGVjdHJvbkZvcmdlTWFrZXIiLCJwbGF0Zm9ybXMiLCJpbmRleE9mIiwicmVzb2x2YWJsZVRhcmdldCIsIk1ha2VyQ2xhc3MiLCJjb25maWciLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwiam9pbiIsImdyZWVuIiwicmVkIiwiZmlsdGVyIiwiXyIsImkiLCJ0IiwiY3lhbiIsInBhY2thZ2VKU09OIiwiYXBwTmFtZSIsInBhY2thZ2VyQ29uZmlnIiwicHJvZHVjdE5hbWUiLCJvdXRwdXRzIiwidGFyZ2V0QXJjaCIsInBhY2thZ2VEaXIiLCJwYXRoIiwicmVzb2x2ZSIsImZzIiwicGF0aEV4aXN0cyIsIl90YXJnZXQiLCJwcmVwYXJlQ29uZmlnIiwiYXJ0aWZhY3RzIiwibWFrZSIsIm1ha2VEaXIiLCJ0YXJnZXRQbGF0Zm9ybSIsInB1c2giLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7QUFFQSxNQUFNQSxTQUFOLFNBQXdCQyxrQkFBeEIsQ0FBdUM7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QUFDRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQge1xuICBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIEZvcmdlQ29uZmlnLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIEZvcmdlTWFrZVJlc3VsdCxcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgTWFrZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCB7IHJ1bkhvb2ssIHJ1bk11dGF0aW5nSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuaW1wb3J0IGdldEN1cnJlbnRPdXREaXIgZnJvbSAnLi4vdXRpbC9vdXQtZGlyJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvZWxlY3Ryb24tdmVyc2lvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuaW1wb3J0IHBhY2thZ2VyIGZyb20gJy4vcGFja2FnZSc7XG5cbmNsYXNzIE1ha2VySW1wbCBleHRlbmRzIE1ha2VyQmFzZTxhbnk+IHtcbiBuYW1lID0gJ2ltcGwnO1xuXG4gZGVmYXVsdFBsYXRmb3JtcyA9IFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogKElGb3JnZVJlc29sdmFibGVNYWtlciB8IE1ha2VyQmFzZTxhbnk+KVtdO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGRpciA9IHByb2Nlc3MuY3dkKCksXG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gIGFyY2ggPSBnZXRIb3N0QXJjaCgpIGFzIEZvcmdlQXJjaCxcbiAgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIGFzIEZvcmdlUGxhdGZvcm0sXG4gIG92ZXJyaWRlVGFyZ2V0cyxcbiAgb3V0RGlyLFxufTogTWFrZU9wdGlvbnMpID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBGb3JnZUNvbmZpZztcbiAgYXdhaXQgYXN5bmNPcmEoJ1Jlc29sdmluZyBGb3JnZSBDb25maWcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIG1ha2VhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gICAgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICB9KTtcblxuICBjb25zdCBhY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnYCk7XG4gIH1cblxuICBjb25zdCBtYWtlcnM6IHtcbiAgICBba2V5OiBudW1iZXJdOiBNYWtlckJhc2U8YW55PjtcbiAgfSA9IHt9O1xuICBsZXQgdGFyZ2V0cyA9IChvdmVycmlkZVRhcmdldHMgfHwgZm9yZ2VDb25maWcubWFrZXJzKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgbmFtZTogdGFyZ2V0IH07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0pO1xuXG4gIGxldCB0YXJnZXRJZCA9IDA7XG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIGlmICgodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyKSB7XG4gICAgICBtYWtlciA9IHRhcmdldCBhcyBNYWtlckJhc2U8YW55PjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgaWYgKG1ha2VyLnBsYXRmb3Jtcy5pbmRleE9mKGFjdHVhbFRhcmdldFBsYXRmb3JtKSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNvbHZhYmxlVGFyZ2V0OiBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIgPSB0YXJnZXQgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyO1xuICAgICAgY29uc3QgTWFrZXJDbGFzcyA9IHJlcXVpcmVTZWFyY2g8dHlwZW9mIE1ha2VySW1wbD4oZGlyLCBbcmVzb2x2YWJsZVRhcmdldC5uYW1lXSk7XG4gICAgICBpZiAoIU1ha2VyQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBtb2R1bGUgd2l0aCBuYW1lOiAke3Jlc29sdmFibGVUYXJnZXQubmFtZX0uIE1ha2Ugc3VyZSBpdCdzIGxpc3RlZCBpbiB0aGUgZGV2RGVwZW5kZW5jaWVzIG9mIHlvdXIgcGFja2FnZS5qc29uYCk7XG4gICAgICB9XG5cbiAgICAgIG1ha2VyID0gbmV3IE1ha2VyQ2xhc3MocmVzb2x2YWJsZVRhcmdldC5jb25maWcsIHJlc29sdmFibGVUYXJnZXQucGxhdGZvcm1zIHx8IHVuZGVmaW5lZCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGlmIChtYWtlci5wbGF0Zm9ybXMuaW5kZXhPZihhY3R1YWxUYXJnZXRQbGF0Zm9ybSkgPT09IC0xKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBNYWtlciBmb3IgdGFyZ2V0ICR7bWFrZXIubmFtZX0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICdlbGVjdHJvbi1mb3JnZSwgcGxlYXNlIHVwZ3JhZGUgb3IgY29udGFjdCB0aGUgbWFpbnRhaW5lciAnLFxuICAgICAgICAnKG5lZWRzIHRvIGltcGxlbWVudCBcXCdpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKVxcJyknLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFhd2FpdCBtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBDYW5ub3QgbWFrZSBmb3IgJHtwbGF0Zm9ybX0gYW5kIHRhcmdldCAke21ha2VyLm5hbWV9OiB0aGUgbWFrZXIgZGVjbGFyZWQgYCxcbiAgICAgICAgYHRoYXQgaXQgY2Fubm90IHJ1biBvbiAke3Byb2Nlc3MucGxhdGZvcm19YCxcbiAgICAgIF0uam9pbignJykpO1xuICAgIH1cblxuICAgIG1ha2Vyc1t0YXJnZXRJZF0gPSBtYWtlcjtcbiAgICB0YXJnZXRJZCArPSAxO1xuICB9XG5cbiAgaWYgKCFza2lwUGFja2FnZSkge1xuICAgIGluZm8oaW50ZXJhY3RpdmUsICdXZSBuZWVkIHRvIHBhY2thZ2UgeW91ciBhcHBsaWNhdGlvbiBiZWZvcmUgd2UgY2FuIG1ha2UgaXQnLmdyZWVuKTtcbiAgICBhd2FpdCBwYWNrYWdlcih7XG4gICAgICBkaXIsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGFyY2gsXG4gICAgICBvdXREaXI6IGFjdHVhbE91dERpcixcbiAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuKGludGVyYWN0aXZlLCAnV0FSTklORzogU2tpcHBpbmcgdGhlIHBhY2thZ2luZyBzdGVwLCB0aGlzIGNvdWxkIHJlc3VsdCBpbiBhbiBvdXQgb2YgZGF0ZSBidWlsZCcucmVkKTtcbiAgfVxuXG4gIHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcigoXywgaSkgPT4gbWFrZXJzW2ldKTtcblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7YCR7dGFyZ2V0cy5tYXAoKHQsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWAuY3lhbn1gKTtcblxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGFwcE5hbWUgPSBmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWU7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IF90YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoYE1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWUuZ3JlZW59IC0gT24gcGxhdGZvcm06ICR7YWN0dWFsVGFyZ2V0UGxhdGZvcm0uY3lhbn0gLSBGb3IgYXJjaDogJHt0YXJnZXRBcmNoLmN5YW59YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ3VycmVudGx5IGl0IGlzIGFzc3VtZWQgd2UgaGF2ZSAxIG1ha2VyIHBlciBtYWtlIGNhbGwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAqIHJlcXVpcmVzIGEgbG9jayB0aGF0IGlzIG5vdCBlbmZvcmNlZC4gIFRoZXJlIGFyZSB0d28gb3B0aW9uczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAqICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgY29uZmlnIGJlaW5nIHByb3ZpZGVkIGFzIGEgbWV0aG9kXG4gICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHRhcmdldEFyY2gsXG4gICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgdGFyZ2V0UGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFydGlmYWN0cyxcbiAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgYXJjaDogdGFyZ2V0QXJjaCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gLFxuICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgcG9zdE1ha2UgaG9va3MgbW9kaWZpZXMgdGhlIGxvY2F0aW9ucyAvIG5hbWVzIG9mIHRoZSBvdXRwdXRzIGl0IG11c3QgcmV0dXJuXG4gIC8vIHRoZSBuZXcgbG9jYXRpb25zIHNvIHRoYXQgdGhlIHB1Ymxpc2ggc3RlcCBrbm93cyB3aGVyZSB0byBsb29rXG4gIHJldHVybiBydW5NdXRhdGluZ0hvb2soZm9yZ2VDb25maWcsICdwb3N0TWFrZScsIG91dHB1dHMpO1xufTtcbiJdfQ==