"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _publishState = _interopRequireDefault(require("../util/publish-state"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _make = _interopRequireDefault(require("./make"));

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const d = (0, _debug.default)('electron-forge:publish');

const publish = async ({
  dir = process.cwd(),
  interactive = false,
  makeOptions = {},
  publishTargets = undefined,
  dryRun = false,
  dryRunResume = false,
  makeResults = undefined,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;

  if (dryRun && dryRunResume) {
    throw new Error("Can't dry run and resume a dry run at the same time");
  }

  if (dryRunResume && makeResults) {
    throw new Error("Can't resume a dry run and use the provided makeResults at the same time");
  }

  const forgeConfig = await (0, _forgeConfig.default)(dir);
  const calculatedOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);

  const dryRunDir = _path.default.resolve(calculatedOutDir, 'publish-dry-run');

  if (dryRunResume) {
    d('attempting to resume from dry run');
    const publishes = await _publishState.default.loadFromDirectory(dryRunDir, dir);

    for (const publishStates of publishes) {
      d('publishing for given state set');
      await publish({
        dir,
        interactive,
        publishTargets,
        makeOptions,
        dryRun: false,
        dryRunResume: false,
        makeResults: publishStates.map(({
          state
        }) => state)
      });
    }

    return;
  }

  if (!makeResults) {
    d('triggering make');
    makeResults = await (0, _make.default)(_objectSpread({
      dir,
      interactive
    }, makeOptions));
  } else {
    // Restore values from dry run
    d('restoring publish settings from dry run');

    for (const makeResult of makeResults) {
      makeOptions.platform = makeResult.platform;
      makeOptions.arch = makeResult.arch;

      for (const makePath of makeResult.artifacts) {
        if (!(await _fsExtra.default.pathExists(makePath))) {
          throw new Error(`Attempted to resume a dry run but an artifact (${makePath}) could not be found`);
        }
      }
    }
  }

  if (dryRun) {
    d('saving results of make in dry run state', makeResults);
    await _fsExtra.default.remove(dryRunDir);
    await _publishState.default.saveToDirectory(dryRunDir, makeResults, dir);
    return;
  }

  const resolvedDir = await (0, _resolveDir.default)(dir);

  if (!resolvedDir) {
    throw new Error('Failed to locate publishable Electron application');
  }

  dir = resolvedDir; // const testPlatform = makeOptions.platform || process.platform as ForgePlatform;

  if (!publishTargets) {
    publishTargets = forgeConfig.publishers || []; // .filter(publisher => (typeof publisher !== 'string' && publisher.platforms)
    //   ? publisher.platforms.indexOf(testPlatform) !== -1 : true);
  }

  publishTargets = publishTargets.map(target => {
    if (typeof target === 'string') {
      return (forgeConfig.publishers || []).find(p => {
        if (typeof p === 'string') return false; // eslint-disable-next-line no-underscore-dangle

        if (p.__isElectronForgePublisher) return false;
        return p.name === target;
      }) || {
        name: target
      };
    }

    return target;
  });

  for (const publishTarget of publishTargets) {
    let publisher; // eslint-disable-next-line no-underscore-dangle

    if (publishTarget.__isElectronForgePublisher) {
      publisher = publishTarget;
    } else {
      const resolvablePublishTarget = publishTarget;
      let PublisherClass;
      await (0, _asyncOra.asyncOra)(`Resolving publish target: ${`${resolvablePublishTarget.name}`.cyan}`, async () => {
        // eslint-disable-line no-loop-func
        PublisherClass = (0, _requireSearch.default)(dir, [resolvablePublishTarget.name]);

        if (!PublisherClass) {
          throw new Error(`Could not find a publish target with the name: ${resolvablePublishTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
        }
      });
      publisher = new PublisherClass(resolvablePublishTarget.config || {}, resolvablePublishTarget.platforms);
    }

    await publisher.publish({
      dir,
      makeResults,
      forgeConfig
    });
  }
};

var _default = publish;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvcHVibGlzaC50cyJdLCJuYW1lcyI6WyJkIiwicHVibGlzaCIsImRpciIsInByb2Nlc3MiLCJjd2QiLCJpbnRlcmFjdGl2ZSIsIm1ha2VPcHRpb25zIiwicHVibGlzaFRhcmdldHMiLCJ1bmRlZmluZWQiLCJkcnlSdW4iLCJkcnlSdW5SZXN1bWUiLCJtYWtlUmVzdWx0cyIsIm91dERpciIsImFzeW5jT3JhIiwiRXJyb3IiLCJmb3JnZUNvbmZpZyIsImNhbGN1bGF0ZWRPdXREaXIiLCJkcnlSdW5EaXIiLCJwYXRoIiwicmVzb2x2ZSIsInB1Ymxpc2hlcyIsIlB1Ymxpc2hTdGF0ZSIsImxvYWRGcm9tRGlyZWN0b3J5IiwicHVibGlzaFN0YXRlcyIsIm1hcCIsInN0YXRlIiwibWFrZVJlc3VsdCIsInBsYXRmb3JtIiwiYXJjaCIsIm1ha2VQYXRoIiwiYXJ0aWZhY3RzIiwiZnMiLCJwYXRoRXhpc3RzIiwicmVtb3ZlIiwic2F2ZVRvRGlyZWN0b3J5IiwicmVzb2x2ZWREaXIiLCJwdWJsaXNoZXJzIiwidGFyZ2V0IiwiZmluZCIsInAiLCJfX2lzRWxlY3Ryb25Gb3JnZVB1Ymxpc2hlciIsIm5hbWUiLCJwdWJsaXNoVGFyZ2V0IiwicHVibGlzaGVyIiwicmVzb2x2YWJsZVB1Ymxpc2hUYXJnZXQiLCJQdWJsaXNoZXJDbGFzcyIsImN5YW4iLCJjb25maWciLCJwbGF0Zm9ybXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQVNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLHdCQUFOLENBQVY7O0FBd0NBLE1BQU1DLE9BQU8sR0FBRyxPQUFPO0FBQ3JCQyxFQUFBQSxHQUFHLEdBQUdDLE9BQU8sQ0FBQ0MsR0FBUixFQURlO0FBRXJCQyxFQUFBQSxXQUFXLEdBQUcsS0FGTztBQUdyQkMsRUFBQUEsV0FBVyxHQUFHLEVB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QWQsRUFBbUIsQ0FBQzBDLHVCQUF1QixDQUFDSCxJQUF6QixDQUFuQixDQUFqQjs7QUFDQSxZQUFJLENBQUNJLGNBQUwsRUFBcUI7QUFDbkIsZ0JBQU0sSUFBSS9CLEtBQUosQ0FBVyxrREFBaUQ4Qix1QkFBdUIsQ0FBQ0gsSUFBSyxxRUFBekYsQ0FBTjtBQUNEO0FBQ0YsT0FMSyxDQUFOO0FBT0FFLE1BQUFBLFNBQVMsR0FBRyxJQUFJRSxjQUFKLENBQ1ZELHVCQUF1QixDQUFDRyxNQUF4QixJQUFrQyxFQUR4QixFQUVWSCx1QkFBdUIsQ0FBQ0ksU0FGZCxDQUFaO0FBSUQ7O0FBRUQsVUFBTUwsU0FBUyxDQUFDMUMsT0FBVixDQUFrQjtBQUN0QkMsTUFBQUEsR0FEc0I7QUFFdEJTLE1BQUFBLFdBRnNCO0FBR3RCSSxNQUFBQTtBQUhzQixLQUFsQixDQUFOO0FBS0Q7QUFDRixDQTNIRDs7ZUE2SGVkLE8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2NvbG9ycyc7XG5pbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IHtcbiAgSUZvcmdlUmVzb2x2YWJsZVB1Ymxpc2hlcixcbiAgSUZvcmdlUHVibGlzaGVyLFxuICBGb3JnZUNvbmZpZ1B1Ymxpc2hlcixcbiAgRm9yZ2VNYWtlUmVzdWx0LFxuICAvLyBGb3JnZVBsYXRmb3JtLFxufSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcbmltcG9ydCBQdWJsaXNoZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9wdWJsaXNoZXItYmFzZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgZ2V0Rm9yZ2VDb25maWcgZnJvbSAnLi4vdXRpbC9mb3JnZS1jb25maWcnO1xuaW1wb3J0IHJlc29sdmVEaXIgZnJvbSAnLi4vdXRpbC9yZXNvbHZlLWRpcic7XG5pbXBvcnQgUHVibGlzaFN0YXRlIGZyb20gJy4uL3V0aWwvcHVibGlzaC1zdGF0ZSc7XG5pbXBvcnQgZ2V0Q3VycmVudE91dERpciBmcm9tICcuLi91dGlsL291dC1kaXInO1xuXG5pbXBvcnQgbWFrZSwgeyBNYWtlT3B0aW9ucyB9IGZyb20gJy4vbWFrZSc7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpwdWJsaXNoJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVibGlzaE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGFwcCB0byBiZSBwdWJsaXNoZWRcbiAgICovXG4gIGRpcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIHNlbnNpYmxlIGRlZmF1bHRzIG9yIHByb21wdCB0aGUgdXNlciB2aXN1YWxseVxuICAgKi9cbiAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIHB1Ymxpc2ggdGFyZ2V0cywgYnkgZGVmYXVsdCBwdWxsZWQgZnJvbSBmb3JnZSBjb25maWcsIHNldCB0aGlzIHByb3AgdG9cbiAgICogb3ZlcnJpZGUgdGhhdCBsaXN0XG4gICAqL1xuICBwdWJsaXNoVGFyZ2V0cz86IEZvcmdlQ29uZmlnUHVibGlzaGVyW107XG4gIC8qKlxuICAgKiBPcHRpb25zIG9iamVjdCB0byBwYXNzZWQgdGhyb3VnaCB0byBtYWtlKClcbiAgICovXG4gIG1ha2VPcHRpb25zPzogTWFrZU9wdGlvbnM7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGdlbmVyYXRlIGRyeSBydW4gbWV0YSBkYXRhIGJ1dCBub3QgYWN0dWFsbHkgcHVibGlzaFxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzdW1lIGEgcHJldmlvdXNseSBzYXZlZCBgZHJ5UnVuYCBhbmQgcHVibGlzaFxuICAgKlxuICAgKiBZb3UgY2FuJ3QgdXNlIHRoaXMgY29tYmluYXRpb24gYXQgdGhlIHNhbWUgdGltZSBhcyBkcnlSdW49dHJ1ZVxuICAgKi9cbiAgZHJ5UnVuUmVzdW1lPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFByb3ZpZGUgcmVzdWx0cyBmcm9tIG1ha2Ugc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGRvZXNuJ3QgcnVuIG1ha2UgaXRzZWxmXG4gICAqL1xuICBtYWtlUmVzdWx0cz86IEZvcmdlTWFrZVJlc3VsdFtdO1xufVxuXG5jb25zdCBwdWJsaXNoID0gYXN5bmMgKHtcbiAgZGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgbWFrZU9wdGlvbnMgPSB7fSxcbiAgcHVibGlzaFRhcmdldHMgPSB1bmRlZmluZWQsXG4gIGRyeVJ1biA9IGZhbHNlLFxuICBkcnlSdW5SZXN1bWUgPSBmYWxzZSxcbiAgbWFrZVJlc3VsdHMgPSB1bmRlZmluZWQsXG4gIG91dERpcixcbn06IFB1Ymxpc2hPcHRpb25zKSA9PiB7XG4gIGFzeW5jT3JhLmludGVyYWN0aXZlID0gaW50ZXJhY3RpdmU7XG5cbiAgaWYgKGRyeVJ1biAmJiBkcnlSdW5SZXN1bWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBkcnkgcnVuIGFuZCByZXN1bWUgYSBkcnkgcnVuIGF0IHRoZSBzYW1lIHRpbWVcIik7XG4gIH1cbiAgaWYgKGRyeVJ1blJlc3VtZSAmJiBtYWtlUmVzdWx0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlc3VtZSBhIGRyeSBydW4gYW5kIHVzZSB0aGUgcHJvdmlkZWQgbWFrZVJlc3VsdHMgYXQgdGhlIHNhbWUgdGltZVwiKTtcbiAgfVxuXG4gIGNvbnN0IGZvcmdlQ29uZmlnID0gYXdhaXQgZ2V0Rm9yZ2VDb25maWcoZGlyKTtcblxuICBjb25zdCBjYWxjdWxhdGVkT3V0RGlyID0gb3V0RGlyIHx8IGdldEN1cnJlbnRPdXREaXIoZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGRyeVJ1bkRpciA9IHBhdGgucmVzb2x2ZShjYWxjdWxhdGVkT3V0RGlyLCAncHVibGlzaC1kcnktcnVuJyk7XG5cbiAgaWYgKGRyeVJ1blJlc3VtZSkge1xuICAgIGQoJ2F0dGVtcHRpbmcgdG8gcmVzdW1lIGZyb20gZHJ5IHJ1bicpO1xuICAgIGNvbnN0IHB1Ymxpc2hlcyA9IGF3YWl0IFB1Ymxpc2hTdGF0ZS5sb2FkRnJvbURpcmVjdG9yeShkcnlSdW5EaXIsIGRpcik7XG4gICAgZm9yIChjb25zdCBwdWJsaXNoU3RhdGVzIG9mIHB1Ymxpc2hlcykge1xuICAgICAgZCgncHVibGlzaGluZyBmb3IgZ2l2ZW4gc3RhdGUgc2V0Jyk7XG4gICAgICBhd2FpdCBwdWJsaXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgICAgcHVibGlzaFRhcmdldHMsXG4gICAgICAgIG1ha2VPcHRpb25zLFxuICAgICAgICBkcnlSdW46IGZhbHNlLFxuICAgICAgICBkcnlSdW5SZXN1bWU6IGZhbHNlLFxuICAgICAgICBtYWtlUmVzdWx0czogcHVibGlzaFN0YXRlcy5tYXAoKHsgc3RhdGUgfSkgPT4gc3RhdGUpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghbWFrZVJlc3VsdHMpIHtcbiAgICBkKCd0cmlnZ2VyaW5nIG1ha2UnKTtcbiAgICBtYWtlUmVzdWx0cyA9IGF3YWl0IG1ha2Uoe1xuICAgICAgZGlyLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICAuLi5tYWtlT3B0aW9ucyxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXN0b3JlIHZhbHVlcyBmcm9tIGRyeSBydW5cbiAgICBkKCdyZXN0b3JpbmcgcHVibGlzaCBzZXR0aW5ncyBmcm9tIGRyeSBydW4nKTtcblxuICAgIGZvciAoY29uc3QgbWFrZVJlc3VsdCBvZiBtYWtlUmVzdWx0cykge1xuICAgICAgbWFrZU9wdGlvbnMucGxhdGZvcm0gPSBtYWtlUmVzdWx0LnBsYXRmb3JtO1xuICAgICAgbWFrZU9wdGlvbnMuYXJjaCA9IG1ha2VSZXN1bHQuYXJjaDtcblxuICAgICAgZm9yIChjb25zdCBtYWtlUGF0aCBvZiBtYWtlUmVzdWx0LmFydGlmYWN0cykge1xuICAgICAgICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMobWFrZVBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gcmVzdW1lIGEgZHJ5IHJ1biBidXQgYW4gYXJ0aWZhY3QgKCR7bWFrZVBhdGh9KSBjb3VsZCBub3QgYmUgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkcnlSdW4pIHtcbiAgICBkKCdzYXZpbmcgcmVzdWx0cyBvZiBtYWtlIGluIGRyeSBydW4gc3RhdGUnLCBtYWtlUmVzdWx0cyk7XG4gICAgYXdhaXQgZnMucmVtb3ZlKGRyeVJ1bkRpcik7XG4gICAgYXdhaXQgUHVibGlzaFN0YXRlLnNhdmVUb0RpcmVjdG9yeShkcnlSdW5EaXIsIG1ha2VSZXN1bHRzLCBkaXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkRGlyID0gYXdhaXQgcmVzb2x2ZURpcihkaXIpO1xuICBpZiAoIXJlc29sdmVkRGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIHB1Ymxpc2hhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gIH1cbiAgZGlyID0gcmVzb2x2ZWREaXI7XG5cbiAgLy8gY29uc3QgdGVzdFBsYXRmb3JtID0gbWFrZU9wdGlvbnMucGxhdGZvcm0gfHwgcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtO1xuICBpZiAoIXB1Ymxpc2hUYXJnZXRzKSB7XG4gICAgcHVibGlzaFRhcmdldHMgPSAoZm9yZ2VDb25maWcucHVibGlzaGVycyB8fCBbXSk7XG4gICAgLy8gLmZpbHRlcihwdWJsaXNoZXIgPT4gKHR5cGVvZiBwdWJsaXNoZXIgIT09ICdzdHJpbmcnICYmIHB1Ymxpc2hlci5wbGF0Zm9ybXMpXG4gICAgLy8gICA/IHB1Ymxpc2hlci5wbGF0Zm9ybXMuaW5kZXhPZih0ZXN0UGxhdGZvcm0pICE9PSAtMSA6IHRydWUpO1xuICB9XG4gIHB1Ymxpc2hUYXJnZXRzID0gKHB1Ymxpc2hUYXJnZXRzIGFzIEZvcmdlQ29uZmlnUHVibGlzaGVyW10pLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gKGZvcmdlQ29uZmlnLnB1Ymxpc2hlcnMgfHwgW10pLmZpbmQoKHA6IEZvcmdlQ29uZmlnUHVibGlzaGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgICAgIGlmICgocCBhcyBJRm9yZ2VQdWJsaXNoZXIpLl9faXNFbGVjdHJvbkZvcmdlUHVibGlzaGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAocCBhcyBJRm9yZ2VSZXNvbHZhYmxlUHVibGlzaGVyKS5uYW1lID09PSB0YXJnZXQ7XG4gICAgICB9KSB8fCB7IG5hbWU6IHRhcmdldCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9KTtcblxuICBmb3IgKGNvbnN0IHB1Ymxpc2hUYXJnZXQgb2YgcHVibGlzaFRhcmdldHMpIHtcbiAgICBsZXQgcHVibGlzaGVyOiBQdWJsaXNoZXJCYXNlPGFueT47XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgaWYgKChwdWJsaXNoVGFyZ2V0IGFzIElGb3JnZVB1Ymxpc2hlcikuX19pc0VsZWN0cm9uRm9yZ2VQdWJsaXNoZXIpIHtcbiAgICAgIHB1Ymxpc2hlciA9IHB1Ymxpc2hUYXJnZXQgYXMgYW55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNvbHZhYmxlUHVibGlzaFRhcmdldCA9IHB1Ymxpc2hUYXJnZXQgYXMgSUZvcmdlUmVzb2x2YWJsZVB1Ymxpc2hlcjtcbiAgICAgIGxldCBQdWJsaXNoZXJDbGFzczogYW55O1xuICAgICAgYXdhaXQgYXN5bmNPcmEoYFJlc29sdmluZyBwdWJsaXNoIHRhcmdldDogJHtgJHtyZXNvbHZhYmxlUHVibGlzaFRhcmdldC5uYW1lfWAuY3lhbn1gLCBhc3luYyAoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIFB1Ymxpc2hlckNsYXNzID0gcmVxdWlyZVNlYXJjaChkaXIsIFtyZXNvbHZhYmxlUHVibGlzaFRhcmdldC5uYW1lXSk7XG4gICAgICAgIGlmICghUHVibGlzaGVyQ2xhc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgcHVibGlzaCB0YXJnZXQgd2l0aCB0aGUgbmFtZTogJHtyZXNvbHZhYmxlUHVibGlzaFRhcmdldC5uYW1lfS4gTWFrZSBzdXJlIGl0J3MgbGlzdGVkIGluIHRoZSBkZXZEZXBlbmRlbmNpZXMgb2YgeW91ciBwYWNrYWdlLmpzb25gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHB1Ymxpc2hlciA9IG5ldyBQdWJsaXNoZXJDbGFzcyhcbiAgICAgICAgcmVzb2x2YWJsZVB1Ymxpc2hUYXJnZXQuY29uZmlnIHx8IHt9LFxuICAgICAgICByZXNvbHZhYmxlUHVibGlzaFRhcmdldC5wbGF0Zm9ybXMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGF3YWl0IHB1Ymxpc2hlci5wdWJsaXNoKHtcbiAgICAgIGRpcixcbiAgICAgIG1ha2VSZXN1bHRzLFxuICAgICAgZm9yZ2VDb25maWcsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHB1Ymxpc2g7XG4iXX0=