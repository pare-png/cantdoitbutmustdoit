"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "StartOptions", {
  enumerable: true,
  get: function () {
    return _sharedTypes.StartOptions;
  }
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _sharedTypes = require("@electron-forge/shared-types");

var _child_process = require("child_process");

var _path = _interopRequireDefault(require("path"));

var _readPackageJson = require("../util/read-package-json");

var _rebuild = _interopRequireDefault(require("../util/rebuild"));

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _electronVersion = require("../util/electron-version");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = async ({
  dir = process.cwd(),
  appPath = '.',
  interactive = false,
  enableLogging = false,
  args = [],
  runAsNode = false,
  inspect = false
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  await (0, _asyncOra.asyncOra)('Locating Application', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate startable Electron application');
    }

    dir = resolvedDir;
  });
  const forgeConfig = await (0, _forgeConfig.default)(dir);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);

  if (!packageJSON.version) {
    throw new Error(`Please set your application's 'version' in '${dir}/package.json'.`);
  }

  await (0, _rebuild.default)(dir, (await (0, _electronVersion.getElectronVersion)(dir, packageJSON)), process.platform, process.arch, forgeConfig.electronRebuildConfig);
  await (0, _hook.runHook)(forgeConfig, 'generateAssets');
  let lastSpawned = null;

  const forgeSpawn = async () => {
    let electronExecPath = null; // If a plugin has taken over the start command let's stop here

    const spawnedPluginChild = await forgeConfig.pluginInterface.overrideStartLogic({
      dir,
      appPath,
      interactive,
      enableLogging,
      args,
      runAsNode,
      inspect
    });
    let prefixArgs = [];

    if (typeof spawnedPluginChild === 'string') {
      electronExecPath = spawnedPluginChild;
    } else if (Array.isArray(spawnedPluginChild)) {
      [electronExecPath, ...prefixArgs] = spawnedPluginChild;
    } else if (spawnedPluginChild) {
      await (0, _hook.runHook)(forgeConfig, 'postStart', spawnedPluginChild);
      return spawnedPluginChild;
    }

    if (!electronExecPath) {
      // eslint-disable-next-line import/no-dynamic-require, global-require
      electronExecPath = require(_path.default.resolve(dir, 'node_modules/electron'));
    }

    const spawnOpts = {
      cwd: dir,
      stdio: 'inherit',
      env: _objectSpread({}, process.env, {}, enableLogging ? {
        ELECTRON_ENABLE_LOGGING: 'true',
        ELECTRON_ENABLE_STACK_DUMPING: 'true'
      } : {})
    };

    if (runAsNode) {
      spawnOpts.env.ELECTRON_RUN_AS_NODE = 'true';
    } else {
      delete spawnOpts.env.ELECTRON_RUN_AS_NODE;
    }

    if (inspect) {
      args = ['--inspect'].concat(args);
    }

    let spawned;
    await (0, _asyncOra.asyncOra)('Launching Application', async () => {
      spawned = (0, _child_process.spawn)(electronExecPath, prefixArgs.concat([appPath]).concat(args), spawnOpts);
    });
    await (0, _hook.runHook)(forgeConfig, 'postStart', spawned);
    return spawned;
  };

  const forgeSpawnWrapper = async () => {
    const spawned = await forgeSpawn(); // When the child app is closed we should stop listening for stdin

    if (spawned) {
      if (interactive && process.stdin.isPaused()) {
        process.stdin.resume();
      }

      spawned.on('exit', () => {
        if (spawned.restarted) return;
        if (!process.stdin.isPaused()) process.stdin.pause();
      });
    } else if (interactive && !process.stdin.isPaused()) {
      process.stdin.pause();
    }

    lastSpawned = spawned;
    return lastSpawned;
  };

  if (interactive) {
    process.stdin.on('data', async data => {
      if (data.toString().trim() === 'rs' && lastSpawned) {
        // eslint-disable-next-line no-console
        console.info('\nRestarting App\n'.cyan);
        lastSpawned.restarted = true;
        lastSpawned.kill('SIGTERM');
        lastSpawned.emit('restarted', (await forgeSpawnWrapper()));
      }
    });
  }

  return forgeSpawnWrapper();
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvc3RhcnQudHMiXSwibmFtZXMiOlsiZGlyIiwicHJvY2VzcyIsImN3ZCIsImFwcFBhdGgiLCJpbnRlcmFjdGl2ZSIsImVuYWJsZUxvZ2dpbmciLCJhcmdzIiwicnVuQXNOb2RlIiwiaW5zcGVjdCIsImFzeW5jT3JhIiwicmVzb2x2ZWREaXIiLCJFcnJvciIsImZvcmdlQ29uZmlnIiwicGFja2FnZUpTT04iLCJ2ZXJzaW9uIiwicGxhdGZvcm0iLCJhcmNoIiwiZWxlY3Ryb25SZWJ1aWxkQ29uZmlnIiwibGFzdFNwYXduZWQiLCJmb3JnZVNwYXduIiwiZWxlY3Ryb25FeGVjUGF0aCIsInNwYXduZWRQbHVnaW5DaGlsZCIsInBsdWdpbkludGVyZmFjZSIsIm92ZXJyaWRlU3RhcnRMb2dpYyIsInByZWZpeEFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJyZXF1aXJlIiwicGF0aCIsInJlc29sdmUiLCJzcGF3bk9wdHMiLCJzdGRpbyIsImVudiIsIkVMRUNUUk9OX0VOQUJMRV9MT0dHSU5HIiwiRUxFQ1RST05fRU5BQkxFX1NUQUNLX0RVTVBJTkciLCJFTEVDVFJPTl9SVU5fQVNfTk9ERSIsImNvbmNhdCIsInNwYXduZWQiLCJmb3JnZVNwYXduV3JhcHBlciIsInN0ZGluIiwiaXNQYXVzZWQiLCJyZXN1bWUiLCJvbiIsInJlc3RhcnRlZCIsInBhdXNlIiwiZGF0YSIsInRvU3RyaW5nIiwidHJpbSIsImNvbnNvbGUiLCJpbmZvIiwiY3lhbiIsImtpbGwiLCJlbWl0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztlQUllLE9BQU87QUFDcEJBLEVBQUFBLEdBQUcsR0FBR0MsT0FBTyxDQUFDQyxHQUFSLEVBRGM7QUFFcEJDLEVBQUFBLE9BQU8sR0FBRyxHQUZVO0FBR3BCQyxFQUFBQSxXQUFXLEdBQUcsS0FI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dkMsTUFBQUEsT0FBTyxDQUFDc0MsS0FBUixDQUFjSyxLQUFkO0FBQ0Q7O0FBRUQxQixJQUFBQSxXQUFXLEdBQUdtQixPQUFkO0FBQ0EsV0FBT25CLFdBQVA7QUFDRCxHQWxCRDs7QUFvQkEsTUFBSWQsV0FBSixFQUFpQjtBQUNmSCxJQUFBQSxPQUFPLENBQUNzQyxLQUFSLENBQWNHLEVBQWQsQ0FBaUIsTUFBakIsRUFBeUIsTUFBT0csSUFBUCxJQUFnQjtBQUN2QyxVQUFJQSxJQUFJLENBQUNDLFFBQUwsR0FBZ0JDLElBQWhCLE9BQTJCLElBQTNCLElBQW1DN0IsV0FBdkMsRUFBb0Q7QUFDbEQ7QUFDQThCLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHFCQUFxQkMsSUFBbEM7QUFDQ2hDLFFBQUFBLFdBQUQsQ0FBcUJ5QixTQUFyQixHQUFpQyxJQUFqQztBQUNBekIsUUFBQUEsV0FBVyxDQUFDaUMsSUFBWixDQUFpQixTQUFqQjtBQUNBakMsUUFBQUEsV0FBVyxDQUFDa0MsSUFBWixDQUFpQixXQUFqQixHQUE4QixNQUFNZCxpQkFBaUIsRUFBckQ7QUFDRDtBQUNGLEtBUkQ7QUFTRDs7QUFFRCxTQUFPQSxpQkFBaUIsRUFBeEI7QUFDRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IFN0YXJ0T3B0aW9ucywgRm9yZ2VQbGF0Zm9ybSwgRm9yZ2VBcmNoIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBzcGF3biwgQ2hpbGRQcm9jZXNzLCBTcGF3bk9wdGlvbnMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyByZWFkTXV0YXRlZFBhY2thZ2VKc29uIH0gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgcmVidWlsZCBmcm9tICcuLi91dGlsL3JlYnVpbGQnO1xuaW1wb3J0IHJlc29sdmVEaXIgZnJvbSAnLi4vdXRpbC9yZXNvbHZlLWRpcic7XG5pbXBvcnQgZ2V0Rm9yZ2VDb25maWcgZnJvbSAnLi4vdXRpbC9mb3JnZS1jb25maWcnO1xuaW1wb3J0IHsgcnVuSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBnZXRFbGVjdHJvblZlcnNpb24gfSBmcm9tICcuLi91dGlsL2VsZWN0cm9uLXZlcnNpb24nO1xuXG5leHBvcnQgeyBTdGFydE9wdGlvbnMgfTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgZGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgYXBwUGF0aCA9ICcuJyxcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgZW5hYmxlTG9nZ2luZyA9IGZhbHNlLFxuICBhcmdzID0gW10sXG4gIHJ1bkFzTm9kZSA9IGZhbHNlLFxuICBpbnNwZWN0ID0gZmFsc2UsXG59OiBTdGFydE9wdGlvbnMpID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBhd2FpdCBhc3luY09yYSgnTG9jYXRpbmcgQXBwbGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIHN0YXJ0YWJsZSBFbGVjdHJvbiBhcHBsaWNhdGlvbicpO1xuICAgIH1cbiAgICBkaXIgPSByZXNvbHZlZERpcjtcbiAgfSk7XG5cbiAgY29uc3QgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG5cbiAgaWYgKCFwYWNrYWdlSlNPTi52ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2Ugc2V0IHlvdXIgYXBwbGljYXRpb24ncyAndmVyc2lvbicgaW4gJyR7ZGlyfS9wYWNrYWdlLmpzb24nLmApO1xuICB9XG5cbiAgYXdhaXQgcmVidWlsZChcbiAgICBkaXIsXG4gICAgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pLFxuICAgIHByb2Nlc3MucGxhdGZvcm0gYXMgRm9yZ2VQbGF0Zm9ybSxcbiAgICBwcm9jZXNzLmFyY2ggYXMgRm9yZ2VBcmNoLFxuICAgIGZvcmdlQ29uZmlnLmVsZWN0cm9uUmVidWlsZENvbmZpZyxcbiAgKTtcblxuICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAnZ2VuZXJhdGVBc3NldHMnKTtcblxuICBsZXQgbGFzdFNwYXduZWQ6IENoaWxkUHJvY2VzcyB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IGZvcmdlU3Bhd24gPSBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGVsZWN0cm9uRXhlY1BhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgLy8gSWYgYSBwbHVnaW4gaGFzIHRha2VuIG92ZXIgdGhlIHN0YXJ0IGNvbW1hbmQgbGV0J3Mgc3RvcCBoZXJlXG4gICAgY29uc3Qgc3Bhd25lZFBsdWdpbkNoaWxkID0gYXdhaXQgZm9yZ2VDb25maWcucGx1Z2luSW50ZXJmYWNlLm92ZXJyaWRlU3RhcnRMb2dpYyh7XG4gICAgICBkaXIsXG4gICAgICBhcHBQYXRoLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICBlbmFibGVMb2dnaW5nLFxuICAgICAgYXJncyxcbiAgICAgIHJ1bkFzTm9kZSxcbiAgICAgIGluc3BlY3QsXG4gICAgfSk7XG4gICAgbGV0IHByZWZpeEFyZ3M6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKHR5cGVvZiBzcGF3bmVkUGx1Z2luQ2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVjdHJvbkV4ZWNQYXRoID0gc3Bhd25lZFBsdWdpbkNoaWxkO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcGF3bmVkUGx1Z2luQ2hpbGQpKSB7XG4gICAgICBbZWxlY3Ryb25FeGVjUGF0aCwgLi4ucHJlZml4QXJnc10gPSBzcGF3bmVkUGx1Z2luQ2hpbGQ7XG4gICAgfSBlbHNlIGlmIChzcGF3bmVkUGx1Z2luQ2hpbGQpIHtcbiAgICAgIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdwb3N0U3RhcnQnLCBzcGF3bmVkUGx1Z2luQ2hpbGQpO1xuICAgICAgcmV0dXJuIHNwYXduZWRQbHVnaW5DaGlsZDtcbiAgICB9XG5cbiAgICBpZiAoIWVsZWN0cm9uRXhlY1BhdGgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlLCBnbG9iYWwtcmVxdWlyZVxuICAgICAgZWxlY3Ryb25FeGVjUGF0aCA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKGRpciwgJ25vZGVfbW9kdWxlcy9lbGVjdHJvbicpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcGF3bk9wdHMgPSB7XG4gICAgICBjd2Q6IGRpcixcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICBlbnY6ICh7XG4gICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAuLi4oZW5hYmxlTG9nZ2luZyA/IHtcbiAgICAgICAgICBFTEVDVFJPTl9FTkFCTEVfTE9HR0lORzogJ3RydWUnLFxuICAgICAgICAgIEVMRUNUUk9OX0VOQUJMRV9TVEFDS19EVU1QSU5HOiAndHJ1ZScsXG4gICAgICAgIH0gOiB7fSksXG4gICAgICB9KSBhcyBOb2RlSlMuUHJvY2Vzc0VudixcbiAgICB9O1xuXG4gICAgaWYgKHJ1bkFzTm9kZSkge1xuICAgICAgc3Bhd25PcHRzLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERSA9ICd0cnVlJztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNwYXduT3B0cy5lbnYuRUxFQ1RST05fUlVOX0FTX05PREU7XG4gICAgfVxuXG4gICAgaWYgKGluc3BlY3QpIHtcbiAgICAgIGFyZ3MgPSBbJy0taW5zcGVjdCcgYXMgKHN0cmluZ3xudW1iZXIpXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgbGV0IHNwYXduZWQhOiBDaGlsZFByb2Nlc3M7XG5cbiAgICBhd2FpdCBhc3luY09yYSgnTGF1bmNoaW5nIEFwcGxpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc3Bhd25lZCA9IHNwYXduKFxuICAgICAgICBlbGVjdHJvbkV4ZWNQYXRoISxcbiAgICAgICAgcHJlZml4QXJncy5jb25jYXQoW2FwcFBhdGhdKS5jb25jYXQoYXJncyBhcyBzdHJpbmdbXSksXG4gICAgICAgIHNwYXduT3B0cyBhcyBTcGF3bk9wdGlvbnMsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RTdGFydCcsIHNwYXduZWQpO1xuICAgIHJldHVybiBzcGF3bmVkO1xuICB9O1xuXG4gIGNvbnN0IGZvcmdlU3Bhd25XcmFwcGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHNwYXduZWQgPSBhd2FpdCBmb3JnZVNwYXduKCk7XG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgYXBwIGlzIGNsb3NlZCB3ZSBzaG91bGQgc3RvcCBsaXN0ZW5pbmcgZm9yIHN0ZGluXG4gICAgaWYgKHNwYXduZWQpIHtcbiAgICAgIGlmIChpbnRlcmFjdGl2ZSAmJiBwcm9jZXNzLnN0ZGluLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRpbi5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICAgIHNwYXduZWQub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgICAgIGlmICgoc3Bhd25lZCBhcyBhbnkpLnJlc3RhcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghcHJvY2Vzcy5zdGRpbi5pc1BhdXNlZCgpKSBwcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGludGVyYWN0aXZlICYmICFwcm9jZXNzLnN0ZGluLmlzUGF1c2VkKCkpIHtcbiAgICAgIHByb2Nlc3Muc3RkaW4ucGF1c2UoKTtcbiAgICB9XG5cbiAgICBsYXN0U3Bhd25lZCA9IHNwYXduZWQ7XG4gICAgcmV0dXJuIGxhc3RTcGF3bmVkO1xuICB9O1xuXG4gIGlmIChpbnRlcmFjdGl2ZSkge1xuICAgIHByb2Nlc3Muc3RkaW4ub24oJ2RhdGEnLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRhdGEudG9TdHJpbmcoKS50cmltKCkgPT09ICdycycgJiYgbGFzdFNwYXduZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5pbmZvKCdcXG5SZXN0YXJ0aW5nIEFwcFxcbicuY3lhbik7XG4gICAgICAgIChsYXN0U3Bhd25lZCBhcyBhbnkpLnJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGxhc3RTcGF3bmVkLmtpbGwoJ1NJR1RFUk0nKTtcbiAgICAgICAgbGFzdFNwYXduZWQuZW1pdCgncmVzdGFydGVkJywgYXdhaXQgZm9yZ2VTcGF3bldyYXBwZXIoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZm9yZ2VTcGF3bldyYXBwZXIoKTtcbn07XG4iXX0=